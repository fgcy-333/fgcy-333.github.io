

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. 为什么使用索引索引  是存储引擎用于   快速找到数据记录   的一种  数据结构    就好比一本教课书的目录部分,通过目录中找到对应文章的页码,便可快速定位到需要的文章 MySQL中也是一样的道理,进行数据查找时,  首先   查看   查询条件    是否   命中某条索引     符合则   通过索引查找相关数据    如果不符合则   需要全表扫描   ,即需要一条一条地查找记录,">
<meta property="og:type" content="article">
<meta property="og:title" content="第06章-索引的数据结构-atguigu-shk">
<meta property="og:url" content="http://example.com/2023/03/30/MySQL-%E5%AE%8B%E7%BA%A2%E5%BA%B7-%E9%AB%98%E7%BA%A7-%E7%AC%AC06%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="FGCY-BLOG">
<meta property="og:description" content="1. 为什么使用索引索引  是存储引擎用于   快速找到数据记录   的一种  数据结构    就好比一本教课书的目录部分,通过目录中找到对应文章的页码,便可快速定位到需要的文章 MySQL中也是一样的道理,进行数据查找时,  首先   查看   查询条件    是否   命中某条索引     符合则   通过索引查找相关数据    如果不符合则   需要全表扫描   ,即需要一条一条地查找记录,">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/mysql.png">
<meta property="article:published_time" content="2023-03-30T12:09:56.000Z">
<meta property="article:modified_time" content="2023-03-30T14:13:02.354Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="尚硅谷-宋红康-MySQL(高级)">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/mysql.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>第06章-索引的数据结构-atguigu-shk - FGCY-BLOG</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":333,"cursorChar":"%","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>FGCY-BLOG</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>主页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签列表</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于我</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/playlist/">
                <i class="iconfont icon-music"></i>
                <span>音乐</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="第06章-索引的数据结构-atguigu-shk"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-30 20:09" pubdate>
          March 30, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第06章-索引的数据结构-atguigu-shk</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h1><p><code>索引</code>  是存储引擎用于   <code>快速找到数据记录</code>   的一种  <code>数据结构</code>   </p>
<p>就好比一本教课书的目录部分,通过目录中找到对应文章的页码,便可快速定位到需要的文章</p>
<p>MySQL中也是一样的道理,进行数据查找时,</p>
<p> 首先   查看   <code>查询条件</code>    是否   <code>命中某条索引</code>    </p>
<p>符合则  <code> 通过索引查找相关数据</code>   </p>
<p>如果不符合则  <code> 需要全表扫描</code>   ,即需要一条一条地查找记录,直到找到与条件符合的记录。</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190028287.png" srcset="/img/loading.gif" lazyload alt="image-20220709093410182"></p>
<hr>
<span id="more"></span>

<p>如上图(左图)所示：数据库没有索引的情况下,数据分布在硬盘不同的位置上面,读取数据时,摆臂需要前后摆动查找数据,这样操作非常消耗时间</p>
<p>如上图(右图)所示：如果数据顺序摆放,那么也需要从1到6行按顺序读取,这样就相当于进行了 <code> 6次 IO 操作</code>,依旧非常耗时</p>
<p>​	如果我们不借助任何索引结构帮助我们快速定位数据的话,我们查找Col 2&#x3D;89这条记录,就要逐行去查找、去比较</p>
<p>​	从col2&#x3D;34开始,进行比较,发现不是,继续下一行。我们当前的表只有不到10行数据,但如果表很大的话,有上千万条数据,就意味着要做很多很多次磁盘I&#x2F;0才能找到	现在要查找Col 2&#x3D;89这条记录。CPU必须先去磁盘查找这条记录,找到之后加载到内存,再对数据进行处理</p>
<p>这个过程 <code>最耗时间</code>  的就是  <code> 磁盘I/0</code>  (涉及到磁盘的旋转时间(速度较快) 、磁头的寻道时间(速度慢、费时))</p>
<p>假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190028544.png" srcset="/img/loading.gif" lazyload alt="image-20220709095331442"></p>
<hr>
<p> <code>对字段Col 2添加了索引</code>  ,就相当于在硬盘上  <code> 为Col2</code>    <code> 维护了一个索引的数据结构</code>   ,这个数据结构为<code>  二叉搜索树</code></p>
<p><code>二叉搜索树</code>  的每个结点存储的是(K, V)结构,  <code>key是  Col 2的值</code>  , value是该key  <code>所在行的文件指针(地址)  </code></p>
<p>比如:</p>
<p>该二叉搜索树的根节点就是: (34,9x07)。现在对Col2添加了索引,这时再去查找Col2&#x3D;89这条记录的时候会先去查找该二叉搜索树(二叉树的遍历查找)</p>
<p>读34到内存,89&gt;34;继续右侧数据,读89到内存,89&#x3D;&#x3D;89;找到数据返回</p>
<p>找到之后就根据当前结点的value快速定位到要查找的记录对应的地址</p>
<p>我们可以发现,只需要查找两次就可以定位到记录的地址,查询速度就提高了</p>
<p>这就是我们为什么要建索引,目的就是为了    <strong>减少磁盘I&#x2F;0的次数</strong>     ,加快查询速率。</p>
<h1 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2. 索引及其优缺点"></a>2. 索引及其优缺点</h1><h2 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h2><p>MySQL官方对索引的定义为：是  <code>帮助MySQL</code>   <code>高效获取数据</code>   的   <code>数据结构</code></p>
<p>索引的本质：</p>
<p><strong>索引</strong>  是   数据结构  你可以简单理解为“<strong>排好序</strong>的<strong>快速查找数据结构</strong>”，满足特定查找算法</p>
<p>这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上<code>实现 高级查找算法 </code></p>
<p>索引  是在   存储引擎   中实现的,因此   每种存储引擎   的  索引  不一定完全相同,并且   每种存储引擎   不一定支持   所有索引类型</p>
<p>同时,存储引擎可以定义每个表的  最大索引数   和  最大索引长度  </p>
<p>所有存储引擎支持每个表   <code>16个索引(上限)</code>   ,  <code>总索引长度为256字节  </code></p>
<p>有些存储引擎支持更多的索引数和更大的索引长度。</p>
<h2 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h2><p>（1）类似大学图书馆建书目索引，<code>提高数据检索的效率</code>，<code>降低 数据库的IO成本</code> ，这也是创建索引最主 要的原因。 </p>
<p>（2）通过  <code>创建唯一索引  </code>，可以保证数据库表中每一行 数据的唯一性 。 </p>
<p>（3）在实现数据的 参考完整性方面，可以<code> 加速表和表之间的连接</code> 。换句话说，<strong>对于有依赖关系的子表和父表联合查询时</strong>， <strong>可以提高查询速度</strong>,</p>
<p>（4）在使用 <code>分组  </code> 和  <code>排序   </code>子句进行数据查询时，可以显著 减少查询中分组和排序的时 间 ，降低了CPU的消耗。</p>
<h2 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h2><p>增加索引也有许多不利的方面，主要表现在如下几个方面： </p>
<p>（1）<code>创建索引  和  维护索引</code>  要<code> 耗费时间</code> ，并 且随着 <code>数据量的增加</code>  ，所耗费的时间也会增加 </p>
<p>（2）<code>索引 </code>  需要    <code>占 磁盘空间</code> ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据		  文 件更快达到最大文件尺寸</p>
<p>（3）虽然   <strong>索引</strong>   <strong>大大提高了查询速度</strong>，同时却会   <code>降低 </code>  <strong>更新表的速度</strong> 。当对表 中的数据进行  <code> 增加、删除和修改</code>   的时候，索引也要动态地维护，这样就降低了 		   数据的维护速度</p>
<p>因此，选择使用索引时，需要   <code> 综合考虑索引的   优 点   和   缺 点</code></p>
<p><strong>小技巧：</strong></p>
<p>索引可以提高查询的速度,但是会影响插入记录的速度</p>
<p>这种情况下,最好的办法是    <code>先删除表中的索引</code>    ,然后  <code> 插入数据</code>   ,  <code>插入完成后</code>  <code>再创建索引  </code></p>
<h1 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3. InnoDB中索引的推演"></a>3. InnoDB中索引的推演</h1><h2 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h2><p>先来看一个精确匹配的例子：</p>
<blockquote>
<p>SELECT [列名列表] FROM 表名 WHERE 列名 &#x3D; xxx;</p>
</blockquote>
<p>1、在一个页中的查找</p>
<p>假设目前表中的记录比较少,所有的记录都可以被存放到一个页（16KB）中,在查找记录的时候可以根据搜索条件的不同分为两种情况:</p>
<p><strong>以主键为搜索条件：</strong></p>
<p>​	可以在  <code>页目录中</code>  使用  <code> 二分法快  速</code>     <code>定位到</code> <code>对应的槽</code>  ,然后再   <code>遍历</code>   <code>该槽对应分组中的记录</code>     即可     <code>快速找到指定的记录</code></p>
<p>​	时间复杂度：O(log<del>2</del>N)</p>
<p><strong>以其他列作为搜索条件：</strong></p>
<p>​	因为在数据页中并没有对非主键列建立所谓的页目录,所以我们无法通过二分法快速定位相应的槽</p>
<p>​	这种情况下只能  <code> 从最小记录</code>   开始   <code>依次遍历</code>   <code>单链表中   </code>的每条记录,然后对比每条记录是不是符合搜索条件。很显然,这种查找的效率是非常低的</p>
<p>​	时间复杂度：O(N)</p>
<p>2、在很多页中查找</p>
<p>大部分情况下我们表中存放的记录都是非常多的,需要  <code>好多的数据页 </code> 来  <code>存储这些记录  </code></p>
<p>在很多页中查找记录的话可以分为两个步骤:</p>
<p>1.定位到记录所在的页</p>
<p>2.从所在的页内中查找相应的记录</p>
<p><strong>在没有索引的情况下</strong>，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录 所在的页，所以只能 <strong>从第一个页</strong> 沿着 双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的</p>
<p>如果一个表有一亿条记录 呢？此时 索引 应运而生</p>
<h2 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE index_demo(<br>        c1 INT,<br>        c2 INT,<br>        c3 CHAR(1),<br>        PRIMARY KEY(c1)<br>) ROW_FORMAT = Compact;<br><br></code></pre></td></tr></table></figure>

<p>这个新建的 index_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用   <code>Compact 行格式</code>  来实际存储记录的</p>
<p>这里我们  <strong>简化了</strong>  index_demo表的  <strong>行格式</strong>  <strong>示意图</strong>    :</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190028221.png" srcset="/img/loading.gif" lazyload alt="image-20220709113204772"></p>
<hr>
<p>我们只在示意图里展示记录的这几个部分：</p>
<ul>
<li><p>record_type ：记录头信息的一项属性，表示  <code>记录的类型</code>  ， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过(目录项记录)，下面讲。</p>
</li>
<li><p>next_record ：记录头信息的一项属性  ，我们用 箭头来表明下一条记录是谁 <strong>（存放下一条记录的地址）</strong></p>
</li>
<li><p>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3</p>
</li>
<li><p>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息</p>
</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190037251.png" srcset="/img/loading.gif" lazyload alt="image-20220709114134135"></p>
<hr>
<p>把一些记录放到页里的示意图就是：</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190037133.png" srcset="/img/loading.gif" lazyload alt="image-20220709114650073"></p>
<hr>
<h3 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？</p>
<p>因为各个页中的记录并没有规 律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以   <code>不得不</code>  依次  <code>遍历所有的数据页</code></p>
<p>所以如果 我们 想  <code>快速的定位  </code> 到需要查找的  <code>记录在哪些数据页</code>  中该咋办？</p>
<p>我们可以  <strong>为</strong>  <code>快速定位记录所在的数据页</code> 而 <strong>建 立一个目录</strong> </p>
<p><strong>建这个目录必须完成下边这些事：</strong></p>
<p>1、下一个数据页中用户记录的  主键值  <code>必须大于</code>    上一个页中用户记录的主键值</p>
<p>假设:每个数据页最多能存放3条记录(实际上一个数据页非常大,可以存放下好多记录)。有了这个假设之后我们向index_demo表插入3条记录:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">INSERT INTO index_demo VALUES<br>(1, 4, &#x27;u&#x27;),<br>(3, 9, &#x27;d&#x27;), <br>(5, 3, &#x27;y&#x27;);<br><br>Query OK, 3 rows affected (0.01 sec)<br></code></pre></td></tr></table></figure>



<p>那么这些记录已经按照主键值的大小串联成一个单向链表了,如图所示:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190037537.png" srcset="/img/loading.gif" lazyload alt="image-20220709115153061"></p>
<hr>
<p>从图中可以看出来, index_demo表中的3条记录都被插入到了编号为10的数据页中了</p>
<p>此时我们再来插入一条记录:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO index_demo VALUES(4, 4, &#x27;a&#x27;);<br></code></pre></td></tr></table></figure>



<p>因为页10最多只能放3条记录,所以我们不得不再   <code>分配一个新页                                                                                   </code>:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190037218.png" srcset="/img/loading.gif" lazyload alt="image-20220709115416936"></p>
<hr>
<p>注意:</p>
<p>新分配的数据页编号可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系</p>
<p>另外,页10中用户记录最大的主键值是5,而页28中有一条记录的主键值是4,因为5&gt;4,所以这就   <strong>不符合</strong>   <code>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</code> 的要求</p>
<p>所以在  <code> 插入主键值为4的记录</code>   的时候  <code> 需要伴随着一次记录移动</code>   ,也就是把主键值为5的记录移动到页28中,然后再把主键值为4的记录插入到页10中</p>
<p>这个过程的示意图如下:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190037558.png" srcset="/img/loading.gif" lazyload alt="image-20220709115839397"></p>
<hr>
<p>这个过程表明了   <code>在对页中的记录进行增删改操作的过程中 </code> ,  <code>我们必须通过一些诸如记录移动的操作</code>  <code>来始终保证这个状态一直成立</code>   :</p>
<p>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</p>
<p>这个过程我们称为 <code>页分裂</code></p>
<p>2、给所有的页建立一个目录项</p>
<p>由于 <code> 数据页的编号可能是不连续</code>   的,所以在向index_demo表中插入许多条记录后,可能是这样的效果:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190036190.png" srcset="/img/loading.gif" lazyload alt="image-20220709141429416"></p>
<hr>
<p>因为这些  <code>16KB的页</code> <code>在物理存储上</code>   是  <code>不连续 </code>  的,所以如果想从这么多页中根据主键值快速定位某些记录所在的页,我们需要给它们做个目录,每个页对应一个目录项</p>
<p>每个目录项包括下边两个部分:</p>
<p>​	<code>页的用户记录中最小的主键值</code> : 我们用key来表示</p>
<p>​	<code>页号</code> : 我们用page_no表示</p>
<p>所以我们为上边几个页做好的目录就像这样子:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190036480.png" srcset="/img/loading.gif" lazyload alt="image-20220709141943983"></p>
<hr>
<p>以 页28 为例，它对应 目录项2 ，这个  、<code>目录项中</code>  包含着  <code>该页的页号 28  </code> 以及   <code>该页中用户记录的最小主 键值 5  </code> </p>
<p>我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了</p>
<p>比如：查找主键值为 20 的记录，具体查找过程分两步：</p>
<p>1、先从目录项中根据 <code>二分法</code> 快速确定出   <code>主键值为 20 的记录在</code>  <code>目录项3 中</code>（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页9 </p>
<p>2、 再根据前边说的在 <code>页中查找记录的方式</code> (二分查找)去 页9 中定位具体的记录</p>
<p> 至此，针对数据页做的  <code>简易目录</code> (雏形) 就搞定了。这个目录有一个别名，称为 索引 。</p>
<h3 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2. InnoDB中的索引方案"></a>2. InnoDB中的索引方案</h3><p><strong>① 迭代1次：目录项纪录的页</strong></p>
<p>上边称为一个  <code>简易的索引方案</code>  ,是因为我们为了在根据主键值进行查找时使用 <code> 二分法</code>  快速定位具体的目录项</p>
<p><strong>假设</strong> 所有目录项都可以在  <strong>物理存储器上连续存储</strong>  ,但是这样做有几个问题 :</p>
<p>​	1、<code>InnoDB</code>  是使用  **页来作为  <code>管理存储空间的基本单位</code>  **   ,最多能保证16KB的连续存储空间,而随着表中记录数量的增多,  <code>需要非常大的连续的存储空间 </code> 才能把所有		 的目录项都放下,这对记录数量非常多的表是不现实的</p>
<p>​	2、我们时常会对记录进行增删,假设我们把页28中的记录都删除了,那意味着目录项2也就没有存在的必要了,这就需要把目录项2后的目录项都向前移动一下,这样		<code> 牵一发而动全身</code>的 <code> 操作效率很差</code></p>
<p>所以,我们需要一种可以  <code>灵活管理所有目录项的方式</code></p>
<p>我们发现目录项其实长得跟我们的用户记录差不多,只不过目录项中的两个列是主键和页号而已,为了和用户记录做一下区分,</p>
<p>我们把这些用来表示目录项的记录称为 <code>目录项记录</code></p>
<p>那InnoDB怎么区分一条记录是普通的用户记录还是目录项记录呢?</p>
<p>使用记录头信息里的<code>record_type</code>属性,它的各个取值代表的意思如下:</p>
<ul>
<li>0:普通的用户记录</li>
<li>1:<code>目录项记录</code></li>
<li>2:最小记录</li>
<li>3:最大记录</li>
</ul>
<p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190036056.png" srcset="/img/loading.gif" lazyload alt="image-20220709143625882"></p>
<hr>
<p>从图中可以看出来，我们新分配了一个编号为30的页来  <code>专门存储目录项记录</code></p>
<p>这里再次强调 <code>目录项记录</code> 和<code>普通的 用户记录</code> 的不同点：</p>
<ul>
<li><p>目录项记录 的 <code>record_type </code>值是1，而 普通用户记录 的 <code>record_type </code>值是0</p>
</li>
<li><p>目录项记录只有 <code>主键值</code>和<code>页的编号 </code>(地址值)    两个列，而普通的用户记录的列是用户自己定义的，可能包含 很 多列 ，另外还有InnoDB自己添加的隐藏列- </p>
</li>
<li><p>了解：记录头信息里还有一个叫 <code>min_rec_mask </code>的属性，只有在存储 目录项记录 的页中的主键值 最小的 <code>目录项记录 的 min_rec_mask 值为 1 </code></p>
<p><code>其他别的记录的 min_rec_mask 值都是 0 </code></p>
</li>
</ul>
<p>相同点：两者用的是一样的数据页，都会   为主键值生成 Page Directory （页目录），从而在按照主键 值进行查找时可以使用 二分法 来加快查询速度</p>
<p> 现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<p>1、先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9</p>
<p>2、再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录</p>
<p><strong>② 迭代2次：多个目录项纪录的页</strong></p>
<hr>
<p><img src="http://img.fgcy.xyz/image-20220709145930742.png" srcset="/img/loading.gif" lazyload alt="image-20220709145930742"></p>
<hr>
<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要  <code>两个新的数据页</code>：</p>
<p>为存储该  <code>用户记录</code>  而新生成了<code> 页31(作为数据页)</code></p>
<p> 因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个   <code>新的 页32(作为目录页)</code> 来存放 <code>页31 对应的目录项</code></p>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤</p>
<p>以查找主键值为 20 的记录为例： </p>
<p>1、确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主	  键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中<code>(通过页目录与二分法查找)</code></p>
<p>2、通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录<code>(根据页目录与二分法获取)</code></p>
<p>3、 在真实存储用户记录的页中定位到具体的记录</p>
<p><strong>③ 迭代3次：目录项记录页的目录页</strong></p>
<p>问题来了,在这个查询步骤的第1步中我们需要  <code> 定位存储目录项记录(数据页)的页</code>   ,但是这些  <code>页是不连续的</code>  ,如果我们表中的数据非常多则会产生很多存储目录项记录的页,那我们怎么根据主键值快速定位一个存储目录项记录的页呢?</p>
<p>那就  <strong>为</strong>  这些  <strong>存储目录项记录的页</strong>  再  <code>生成一个更高级的目录</code> ,就像是一个多级目录一样,大目录里嵌套小目录,小目录里才是实际的数据</p>
<p>所以现在各个页的示意图就是这样子:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190036068.png" srcset="/img/loading.gif" lazyload alt="image-20220709150230444"></p>
<hr>
<p>如图上图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录</p>
<p>我们可以用下边这个图来描述它：</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190034611.png" srcset="/img/loading.gif" lazyload alt="image-20220709151831430"></p>
<hr>
<p>这个数据结构，它的名称是 B+树 </p>
<p>④ B+Tree<br>不论是  <code>存放用户记录  </code> 的   数据页   ,还是   <code>存放目录项记录</code>   的  数据页(也可以称为目录页)   ,我们都把它们存放到B+树这个数据结构中了,所以我们也称这些数据页为节点。</p>
<p>从图中可以看出,我们的  <strong>实际用户记录</strong>   其实都存放在   <strong>B+树的最底层的节点</strong>   上,这些节点也被称为   <strong>叶子节点</strong>  ,其余用来存放目录项的节点称为  <strong>非叶子节点</strong>  或者内节点,其中   B+树最上边的那个节点   也称为  <strong>根节点</strong>。</p>
<p> 一个B+树的节点其实可以分成好多层,规定  <strong>最下边的那层</strong>  ,也就是   <strong>存放我们用户记录</strong>   的那层为  <strong>第0层</strong>  ,之后依次往上加。</p>
<p>之前我们做了一个非常极端的假设:存放用户记录的页最多存放3条记录,存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的</p>
<p>假设</p>
<p>所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录,所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录,那么:</p>
<ul>
<li>如果B+树只有1层,也就是只有1个用于存放用户记录的节点,最多能存放100条记录。</li>
<li>如果B+树有2层,最多能存放1000x100&#x3D;10，0000条记录。（十万条记录）<br>如果B+树有3层,最多能存放1000x1000x100&#x3D;1，0000，0000条记录。(一个小目标)</li>
<li>如果B+树有4层,最多能存放1000x1000x1000x100&#x3D;1000,0000,0000条记录。相当多的记录!（一千个小目标）</li>
</ul>
<p>你的表里能存放100000000000条记录吗?</p>
<p>所以一般情况下,我们用到的B+树都不会超过4层,那我们通过主键值去查找某条记录最多只需要做4个页面内的查找(查找3个目录项页和一个用户记录页),又因为在每个页面内有所谓的Page Directory (页目录),所以在页面内也可以通过二分法实现快速定位记录。</p>
<p>注意：</p>
<blockquote>
<p>一般来说，不希望B+Tress 的树高超过3层，每一层代表一次IO；</p>
</blockquote>
<h2 id="3-3常见索引概念"><a href="#3-3常见索引概念" class="headerlink" title="3.3常见索引概念"></a>3.3常见索引概念</h2><p>索引按照   <strong>物理实现方式</strong> : 索引可以分为2种:   聚簇(聚集)  和  非聚簇(非聚集)索引。</p>
<p>我们也把  <strong>非聚集索引</strong>  称为  <strong>二级索引</strong>或者   <strong>辅助索引</strong>  。</p>
<h3 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1.聚簇索引"></a>1.聚簇索引</h3><p>聚簇索引并   <strong>不是</strong>   一种单独的  <strong>索引类型</strong>  ,而是一种   <strong>数据存储方式</strong>   <code>(所有的用户记录都存储在了叶子节点)</code></p>
<p>也就是所谓的   <strong>索引即数据</strong>   ,   <strong>数据即索引</strong>  </p>
<blockquote>
<p>术语”聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p>
</blockquote>
<p>特点:</p>
<ol>
<li>使用  <code>记录主键值的大小 </code>  进行  <code>记录和页 </code> 的排序   ,这包括三个方面的含义:</li>
</ol>
<ul>
<li><p><strong>页内的记录</strong>  是按照   <strong>主键的大小顺序</strong>   排成一个  单向链表  </p>
</li>
<li><p>各个   <strong>存放用户记录的页</strong>   也是   根据   <strong>页中用户记录的主键大小顺序</strong>   排成一个  <strong>双向链表</strong>  </p>
</li>
<li><p>存放  <code>目录项记录的页 </code> 分为不同的层次,在   <strong>同一层次中的页</strong>   也是根据   页中  <strong>目录项记录的主键大小</strong>  顺序   排成一个  <strong>双向链表</strong></p>
</li>
</ul>
<ol start="2">
<li>B+树的 叶子节点 存储的是完整的用户记录。</li>
</ol>
<ul>
<li>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</li>
</ul>
<p>优点： </p>
<ul>
<li>数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快 </li>
<li>聚簇索引对于主键的 排序查找 和 范围查找 速度非常快 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 节省了大量的io操作。</li>
</ul>
<p>缺点： </p>
<ul>
<li>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键 。</li>
<li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为 不可更新 。</li>
<li>二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ul>
<p>限制:</p>
<ul>
<li><p>对于MySQL数据库自前只有InnoDB数据引擎支持聚簇索引,而MyISAM并不支持聚簇索引。</p>
</li>
<li><p>由于数据物理存储排序方式只能有一种,所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键。【一个表中主键最多有一个，可以为零】</p>
</li>
<li><p>如果没有定义主键,Innodb会选择  <strong>非空的唯一索引</strong>  代替。如果没有这样的索引,Innodb会 <strong>隐式的定义一个主键</strong> 来作为聚簇索引【隐藏列，非空唯一】。</p>
</li>
<li><p>为了充分利用聚簇索引的  <strong>聚簇的特性</strong>  ,所以innodb表的  <strong>主键列尽量选用有序</strong>  的顺序id,而不建议用无序的id</p>
<p>比如UUID, MD5、HASH、字符串列作为主键  <strong>无法保证数据  的顺序增长</strong>。</p>
</li>
</ul>
<h3 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h3><p>【不完整，后面会说】</p>
<p>上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用,因为B+树中的数据都是按照主键进行排序的。</p>
<p>那如果我们想以别的列作为搜索条件该怎么办呢?肯定不能是从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案:</p>
<p>我们可以多建几棵B+树,不同的B+树中的数据采用不同的排序规则。</p>
<p>比方说我们用c2列的大小作为数据页、页中记录的排序规则,再建一棵B+树,效果如下图所示:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190034059.png" srcset="/img/loading.gif" lazyload alt="image-20220821164701978"></p>
<hr>
<p>按C2升序排列。</p>
<p>目录页的记录值会包含索引的id值，以及页号。</p>
<p>注意：会包含主键的值。</p>
<p>这个B+树与上边介绍的聚簇索引有几处不同:</p>
<p>使用记录c2列的大小进行   <strong>记录和页</strong>  的排序,这包括三个方面的含义:</p>
<ul>
<li>页内的记录是按照c2列的大小顺序排成一个单向链表。</li>
<li>各个存放<code>用户记录的页</code>也是根据页中记录的c2列大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次,在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成个双向链表。</li>
<li>B+树的叶子节点存储的并不是完整的用户记录,而只是c2列+主键这两个列的值。</li>
<li>目录项记录中不再是主键+页号的搭配,而变成了c2列+页号的搭配。</li>
</ul>
<p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。</p>
<p>以查找c2列的值为4的记录为例, 查找过程如下:</p>
<ol>
<li>确定目录项记录页。</li>
</ol>
<ul>
<li>根据根页面,也就是页44,可以快速定位到目录项记录所在的页为页42 (因为2&lt;42&lt;9)。</li>
</ul>
<ol start="2">
<li>通过目录项记录页确定用户记录真实所在的页。</li>
</ol>
<ul>
<li><p>在页42中可以快速定位到实际存储用户记录的页,但是由于c2列并没有唯一性约束,所以c2列值为4的记录可能分布在多个数据页中</p>
<p>又因为2&lt;4&lt;&#x3D;4,所以确定实际存储用户记录的页在页34和页35中。</p>
</li>
</ul>
<ol start="3">
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ol>
<ul>
<li>到页34和页35中定位到具体的记录。</li>
</ul>
<ol start="4">
<li>但是这个B+树的叶子节点中的记录只存储了c2和c1(也就是主键)两个列,所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li>
</ol>
<p>概念：回表 </p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！ </p>
<p>问题：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p>
<ul>
<li><p>如果把完整的用户记录放到叶子节点是可以不用回表。但是太占地方了,相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍,这就有点太浪费存储空间了。</p>
</li>
<li><p>因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录,所以这种B+树也被称为二级索引(英文名secondary index),或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则,所以我们也称这个B+树是为c2列建立的索引。</p>
</li>
</ul>
<p>非聚簇索引的存在不影响数据在聚簇索引中的组织,所以一张表可以有多个非聚簇索引。</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190034911.png" srcset="/img/loading.gif" lazyload alt="image-20220821170535348"></p>
<hr>
<p>小结:</p>
<p>聚簇索引与非聚簇索引的原理不同,在使用上也有一些区别:</p>
<ol>
<li>聚簇索引的叶子节点存储的就是我们的数据记录,非聚簇索引的叶子节点存储的是数据位置(索引的值以及主键的值)。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表只能有 <strong>一个聚簇索引</strong>,因为只能有一种排序存储的方式,但可以<strong>有多个非聚簇索引</strong>,也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候,数据的查询效率高,但如果对数据进行插入,删除,更新等操作,效率会比非聚簇索引低。</li>
</ol>
<h3 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引"></a>3. 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时<strong>为多个列建立索引</strong></p>
<p>比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义： </p>
<ul>
<li><p>先把各个记录和页按照c2列进行排序。 </p>
</li>
<li><p>在记录的c2列相同的情况下，采用c3列进行排序</p>
</li>
</ul>
<p>为C1与C2建立的联合索引如下：</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190036161.png" srcset="/img/loading.gif" lazyload alt="image-20220919003609231"></p>
<hr>
<p>如图所示,我们需要注意以下几点:</p>
<ul>
<li>每条目录项记录都由c2、c3、页号这三个部分组成,各条记录先按照c2列的值进行排序,如果记录的c2列相同,则按照c3列的值进行排序。</li>
<li>B+树叶子节点处的用户记录由c2、c3和主键c1列组成。</li>
</ul>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引（非聚簇索引）</p>
<p>它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li><p>建立 联合索引 只会建立如上图一样的 <strong>一棵B+树</strong>。 </p>
</li>
<li><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则<strong>建立2棵B+树</strong>。</p>
</li>
</ul>
<h2 id="3-4-InnoDB的B-树索引的注意事项"><a href="#3-4-InnoDB的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB的B+树索引的注意事项"></a>3.4 InnoDB的B+树索引的注意事项</h2><h3 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h3><p>我们前边介绍B+树索引的时候,为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点</p>
<p>实际上B+树的形成过程是这样的:</p>
<ul>
<li><p>每当为某个表创建一个B+树索引(聚簇索引不是人为创建的,默认就有)的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候,每个B+树索引对应的根节点中既没有用户记录,也没有目录项记录</p>
</li>
<li><p>随后向表中插入用户记录时,先把用户记录存储到这个根节点中。</p>
</li>
<li><p>当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中,然后对这个新页进行页分裂的操作，得到另一个新页,比如页b。这时新插入的记录根据键值(也就是聚簇索引中的主键值,二级索引中对应的索引列的值)的大小就会被分配到页a或者页b中,而根节点便升级为存储目录项记录的页。</p>
</li>
</ul>
<p>这个过程特别注意的是: </p>
<p>一个B+树索引的根节点自诞生之日起,便不会再移动。这样只要我们对某个表建立一个索引,那么它的根节点的页号便会被记录到某个地方。</p>
<p>然后凡是 <strong>InnoDB存储引擎需要用到这个索引</strong>  的时候,都会从那个  <strong>固定的地方</strong>  **取出根节点的页号,**从而来访问这个索引。 </p>
<h3 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h3><p>我们知道B+树索引的  内节点  中目录项记录的内容是 <code>  索引列+页号</code>  的搭配, 但是这个搭配对于二级索引来说有点儿不严谨。</p>
<p>还拿index_demo表为例,假设这个表中的数据是这样的:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190034498.png" srcset="/img/loading.gif" lazyload alt="image-20220822214812417"></p>
<hr>
<p>如果二级索引中目录项记录的内容只是  <strong>索引列+页号</strong>  的搭配的话,那么为c2列建立索引后的B+树  <strong>应该</strong>  长这样:【实际上目录页中的目录项会有主键】</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190034528.png" srcset="/img/loading.gif" lazyload alt="image-20220822222006892"></p>
<hr>
<p>如果我们想新插入一行记录,其中c1、c2、c3的值分别是:9、1、’c’,那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题:</p>
<p>由于页3中存储的目录项记录是 <code>****</code>  的值构成的,页3中的两条目录项记录对应的c2列的值都是1,而我们新插入的这条记录的c2列的值也是1,那我们这条新插入的记录到底应该放到页4中,还是应该放到页5中啊?</p>
<p>答案是:对不起,错了。</p>
<p>为了让新插入记录能找到自己在那个页里,我们需要保证在B+树的同一层内节点的  <strong>目录项记录</strong> <code> 除页号这个字段外</code> 还是是<strong>唯一的</strong>。</p>
<p>所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的:</p>
<ul>
<li><p>索引列的值</p>
</li>
<li><p>主键值</p>
</li>
<li><p>页号</p>
</li>
</ul>
<p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了 , 这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的。</p>
<p>所以我们为c2列建立二级索引后的示意图  <strong>实际上</strong>  应该是这样子的:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190034402.png" srcset="/img/loading.gif" lazyload alt="image-20220822223357140"></p>
<hr>
<p>这样我们再插入记录(9, 1, ‘c’)时,由于页3中存储的目录项记录是由 <code> c2列+主键+页号</code>  的值构成的</p>
<p>可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较,如果c2列的值相同的话,可以接着比较主键值,因为B+树同一层中不同目录项记录的<code> c2列+主键</code>  的值  <strong>肯定是不一样的</strong>,所以最后肯定能定位唯一的一条目录项记录,在本例中最后确定新记录应该被插入到页5中。</p>
<p>​	</p>
<h3 id="3-一个页面最少存储2条记录"><a href="#3-一个页面最少存储2条记录" class="headerlink" title="3. 一个页面最少存储2条记录"></a>3. 一个页面最少存储2条记录</h3><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录,查询速度相当不错!这是因为B+树本质上就是一个大的多层级目录,每经过一个目录时都会过滤掉许多无效的子目录,直到最后访问到存储真实数据的目录。</p>
<p>那如果一个大的目录中只存放一个子目录是个啥效果呢?那就是目录层级非常非常非常多,而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录?所以InnoDB的一个数据页至少可以存放两条记录。【实际肯定是远大于两条的】</p>
<h1 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h1><h3 id="4-1-适应B-Tree的存储引擎"><a href="#4-1-适应B-Tree的存储引擎" class="headerlink" title="4.1 适应B+Tree的存储引擎"></a>4.1 适应B+Tree的存储引擎</h3><p>B树索引适用存储引擎如表所示：【在MySQL中写B-Tree其实就是 B+Tree】</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190034354.png" srcset="/img/loading.gif" lazyload alt="image-20220822224052369"></p>
<hr>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。</p>
<p><code>Innodb </code> 和  <code>MyISAM </code>默认的索 引是<code>Btree索引</code>.</p>
<p>而Memory默认的索引是Hash索引。 </p>
<p><code>MyISAM引擎</code> 使用 B+Tree 作为索引结构，叶子节点的  <strong>data域</strong>  存放的是 数据记录<strong>的地址</strong> 。</p>
<h3 id="4-2-MyISAM索引的原理"><a href="#4-2-MyISAM索引的原理" class="headerlink" title="4.2 MyISAM索引的原理"></a>4.2 MyISAM索引的原理</h3><p>我们知道InnoDB中 <strong>索引即数据</strong> ,也就是 <strong>聚簇索引</strong> 的 <strong>那棵B+树的叶子节点中</strong> 已经把所有完整的用户记录都包含了</p>
<p>而<code>MyISAM的索引</code>方案虽然也使用树形结构 , 但是却将  <strong>索引和数据  分开存储</strong>:</p>
<ul>
<li>将表中的记录按照   <strong>记录的插入顺序</strong>  单独存储   在一个文件中,称之为  <strong>数据文件</strong>。这个文件并不划分为若干个数据页,有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并  <strong>没有刻意按照主键大小排序</strong>,所以我们并  <strong>不能</strong>  在这些数据上使用  <strong>二分法进行查找</strong>。</li>
<li>使用<code>MyISAM存储引擎</code>的表会把  <strong>索引信息</strong>  另外存储到一个称为  <strong>索引文件</strong>  的另一个文件中。MyISAM会单独为表的  <strong>主键创建一个索引</strong>,只不过在索引的叶子节点中存储的不是完整的用户记录,而是  <strong>主键值+数据记录地址</strong>  的组合。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /var/lib/mysql<br>cd ./dbtest1<br>ll<br></code></pre></td></tr></table></figure>

<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190034296.png" srcset="/img/loading.gif" lazyload alt="image-20220822225530535"></p>
<hr>
<p>下图是MyISAM索引的原理图:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190033274.png" srcset="/img/loading.gif" lazyload alt="image-20220822225746931"></p>
<p>这里设表一共有三列,假设我们以col1为主键,上图是一个<strong>MyISAM表的主索引</strong>(Primary key)示意。可以看出<code> MyISAM的索引文件</code> 仅仅保存  <strong>数据记录的地址</strong>。</p>
<p>在MyISAM中,  <strong>主键索引</strong>  和  <strong>二级索引</strong>  (Secondary key)在  <strong>结构上  没有任何区别</strong>,只是主键索引要求key是唯一的,而二级索引的key可以重复。</p>
<p>如果我们在Col2上建立一个二级索引,则此索引的结构如下图所示:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190034463.png" srcset="/img/loading.gif" lazyload alt="image-20220822230239163"></p>
<hr>
<p>同样也是一棵<code>B+Tree</code>, data域保存  <strong>数据记录的地址</strong> 。</p>
<p>因此 , MyISAM中索引检索的算法为:</p>
<p>首先按照B+Tree搜索算法搜索索引,如果指定的Key存在,则取出其data域的值,然后以data域的值为地址,读取相应数据记录。</p>
<h3 id="4-3-MyISAM-与-InnoDB对比"><a href="#4-3-MyISAM-与-InnoDB对比" class="headerlink" title="4.3 MyISAM 与 InnoDB对比"></a>4.3 MyISAM 与 InnoDB对比</h3><p>MyISAM的索引方式  <strong>都是“非聚簇”的</strong>，与InnoDB  <strong>包含1个聚簇索引</strong>  是不同的。</p>
<p>小结两种引擎中索引的区 别：</p>
<p>① <code>在InnoDB存储引擎</code>中，我们只需要根据主键值对 <strong>聚簇索引</strong> 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 <strong>回表</strong> 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。 </p>
<p>② <code>InnoDB</code>的  <strong>数据文件本身就是索引文件</strong> ，而 MyISAM  <strong>索引文件 和 数据文件是 分离</strong>的 ，索引文件仅保存 <strong>数 据记录的地址</strong>。 </p>
<p>③ <strong>InnoDB</strong>  的   <strong>非聚簇索引</strong>  <code>data域</code>  存储相应记录 <strong>主键的值</strong> ，而MyISAM索引记录的是 <strong>地址</strong> 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域中的某个值。 </p>
<p>④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。 </p>
<p>⑤ InnoDB要求表 必须有主键 （ MyISAM可以没有 )。如果没有显式指定，则MySQL系统会自动选择一个 可以  <strong>非空且唯一</strong>  标识数据记录的列作为主键。如果<strong>不存在这种列</strong>，则MySQL自动为InnoDB表生成一个<strong>隐 含字段</strong>  作为主键，这个字段长度为<strong>6个字节</strong>，类型为<strong>长整型</strong>。</p>
<p>小结:</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如:</p>
<p>举例1:知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为<code>所有二级索引</code>都引用主键索引,过长的主键索引会令二级索引变得过大。</p>
<p>举例2:用非单调的字段作为主键在InnoDB中不是个好主意,因为InnoDB数据文件本身是一棵B+Tree,非单调的主键会造成在插入新记录时,数据文件为了维持B+Tree的特性而频繁的  <strong>分裂调整</strong>  【页分裂】,十分低效,而使用  <strong>自增字段</strong>  作为主键则是一个很好的选择。</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209190033705.png" srcset="/img/loading.gif" lazyload alt="image-20220822232017089"></p>
<hr>
<h1 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h1><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗： </p>
<p>空间上的代价 ：</p>
<ul>
<li>每建立  <strong>一个索引</strong>  都要为它建立 <strong>一棵B+树</strong>，每  <strong>一棵B+树</strong>  的每  <strong>一个节点都是一个数据页</strong>，一个页默认会 占用 <strong>16KB 的存储空间</strong>，一棵很大的B+树由许多数据页组成，那就是<strong>很大的一片存储空间</strong>。</li>
</ul>
<p>时间上的代价：</p>
<ul>
<li><p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。</p>
<p>而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。</p>
<p>不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。</p>
<p>而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
</li>
</ul>
<blockquote>
<p>一个表上索引建的越多,就会占用越多的存储空间,在增删改记录的时候性能就越差。</p>
<p>为了能建立又好又少的索引,我们得学学这些索引在哪些条件下起作用的。</p>
</blockquote>
<h1 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6. MySQL数据结构选择的合理性"></a>6. MySQL数据结构选择的合理性</h1><p>从MySQL的角度讲,不得不考虑一个现实问题就是磁盘IO。</p>
<p>如果我们能让  <strong>索引的数据结构</strong>  <strong>尽量减少硬盘的1&#x2F;0操作</strong>  ,所消耗的时间也就越小。</p>
<p>问题：是否可以将索引全部加载进内存？</p>
<p>不行。</p>
<p>查找都是索引操作,一般来说索引非常大,尤其是关系型数据库,当数据量比较大的时候,索引的大小有可能  <strong>几个G</strong>  甚至  <strong>更多</strong>,为了减少索引在内存的占用,数据库索引是存储在外部磁盘上的。</p>
<p>当我们利用索引查询的时候,不可能把整个索引全部加载到内存,只能逐一加载。需要的时候就加载。<strong>要让需要的次数尽可能少</strong></p>
<p>那么  <strong>MySQL衡量查询效率的标准</strong>  就是  <strong>磁盘10次数</strong>。磁盘的I&#x2F;0操作次数对索引的使用效率至关重要。</p>
<h2 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h2><p> 假设要找的数据在最后一条，则需要遍历所有的数据。效率非常低。</p>
<h2 id="6-2-Hash结构"><a href="#6-2-Hash结构" class="headerlink" title="6.2 Hash结构"></a>6.2 Hash结构</h2><p>Hash 本身是一个函数,又被称为散列函数,它可以帮助我们大幅提升检索数据的效率。</p>
<p>Hash 算法是通过某种确定性的算法(比如MD5,SHA1,SHA2,SHA3)将输入转变为输出。<strong>相同的输入永远可以得到相同的输出</strong></p>
<p>假设输入内容有微小偏差,在输出中通常会有不同的结果。</p>
<p>举例:</p>
<p>如果你想要验证两个文件是否相同,那么你不需要把两份文件直接拿来比对,只需要让对方把Hash函数计算得到的结果告诉你即可,然后在本地同样对文件进行Hash函数的运算,最后通过比较这两个Hash函数的结果是否相同,就可以知道这两个文件是否相同。</p>
<p>加速查找速度的数据结构,常见的有两类:</p>
<p>(1)树,例如<strong>平衡二叉搜索树</strong>,  查询 &#x2F; 插入 &#x2F; 修改 &#x2F; 删除的  平均时间复杂度都是<code>0(1og2N)</code>;</p>
<p>(2)哈希,例如<code>HashMap</code>, 查询 &#x2F; 插入 &#x2F; 修改 &#x2F; 删除 的平均时间复杂度都是<code>0(1)</code></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208282230091.png" srcset="/img/loading.gif" lazyload alt="image-20220828223018600"></p>
<hr>
<p>采用Hash进行检索效率非常高,基本上一次检索就可以找到数据,而B+树需要自顶向下依次查找,多次访问节点才能找到数据,中间需要多次I&#x2F;0操作, 从效率来说Haah比B+树更快。</p>
<p>在哈希的方式下,一个元素k处于h(k)中,即利用哈希函数h,根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T[o…m-1]的槽位上。</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208282235787.png" srcset="/img/loading.gif" lazyload alt="image-20220828223522762"></p>
<hr>
<p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链 接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，</p>
<p>如下图所示：</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208282236321.png" srcset="/img/loading.gif" lazyload alt="image-20220828223612653"></p>
<hr>
<p>实验:体会数组和hash表的查找方面的效率区别：</p>
<p>数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 算法复杂度为 O(n)</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100000</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">//数组下标索引范围 0~99999</span><br>        <span class="hljs-comment">//数组元素范围1~100000</span><br>        arr[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">//循环1~100000 每次拿循环中的次数作为索引去数组中获取值</span><br>    <span class="hljs-comment">//然后拿这个值与数组中的每一个元素比较，找到就下一次。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100000</span>; j++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (temp == arr[i]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;time： &quot;</span> + (end - start)); <span class="hljs-comment">//time： 823</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>HashSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//算法复杂度为 O(1)</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(<span class="hljs-number">100000</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>        set.add(i + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100000</span>; j++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> j;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">contains</span> <span class="hljs-operator">=</span> set.contains(temp);<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;time： &quot;</span> + (end - start)); <span class="hljs-comment">//time： 5</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>这两种数据结构的比较，实际上是全表扫描和通过hash结构查找数据。</p>
<p>Hash结构效率高,那为什么索引结构要设计成树型呢?</p>
<ul>
<li><p>原因1: </p>
<p>Hash索引仅能满足(&#x3D;) (&lt;&gt;)和IN查询。<strong>等于 不等于 小范围内的等于</strong></p>
<p>如果进行范围查询,哈希型的索引,时间复杂度会退化为<code>O(n)</code>；而树型的“有序”特性,依然能够保持<code>O(log2N)</code>的高效率。</p>
<p>B+树中数据是有序的，可以通过二分法查找数据，所以是<code>O(log2N)</code></p>
</li>
<li><p>原因2: </p>
<p>Hash索引还有一个缺陷,数据的存储是没有顺序的,在ORDER BY的情况下,使用Hash索引还需要对数据重新排序。</p>
</li>
<li><p>原因3:对于联合索引的情况,Hash值是将联合索引键合并后一起来计算的,无法对单独的一个键或者几个索引键进行查询。也就是说联合索引中有几个键，就必须将全部的键取hash值。【此时就会出现一个问题，假如abc获取到的hash值，与jui获取到的hash值是相等时，无法判断该取那条记录】</p>
</li>
<li><p>原因4:对于等值查询来说,通常Hash索引的效率更高,不过也存在一种情况,就是索引列的重复值如果很多,效率就会降低。</p>
<p>这是因为遇到Hash冲突时,需要遍历桶中的行指针来进行比较,找到查询的关键字,非常耗时。</p>
<p>所以,Hash索引通常  <strong>不会用到重复值多的列</strong> 上,比如列为性别、年龄的情况等。</p>
</li>
<li><p>Hash索引适用存储引擎，如表所示:</p>
</li>
</ul>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208282305467.png" srcset="/img/loading.gif" lazyload alt="image-20220828230532628"></p>
<hr>
<p>Hash是Memory存储引擎的 默认索引结构。</p>
<p>Hash索引的适用性：</p>
<p>Hash索引存在着很多限制,相比之下在数据库中B+树索引的使用面会更广,不过也有一些场景采用Hash索引效率更高,比如在键值型(Key-Value)数据库中, Redis 存储的核心就是Hash表。</p>
<p>MySQL中的Memory存储引警支持Hash存储,如果我们需要用到查询的临时表时,就可以选择Memory存储引擎,把某个字段设置为Hash索引,比如字符串类型的字段,进行Hash计算之后长度可以缩短到几个字节。当   <strong>字段的重复度低</strong>  ,而且   <strong>经常需要进行等值查询的时候</strong>   ,采用Hash索引是个不错的选择。</p>
<p>另外, <code>InnoDB</code>本身  不支持 <code> Hash索引</code>,但是 <strong>提供</strong> <strong>自适应Hash 索引</strong>(Adaptive Hash Index)。</p>
<p>什么情况下才会使用自适应Hash索引呢?</p>
<p>如果某个数据经常被访问,当满足一定条件的时候,就会将这个数据页的地址存放到Hash表中。这样下次查询的时候,就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash索引的优点。</p>
<p>InnoDb的自适应Hash</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208282311453.png" srcset="/img/loading.gif" lazyload alt="image-20220828231154130"></p>
<hr>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。 </p>
<p>我们可以通过<code>innodb_adaptive_hash_index</code>变量来查看是否开启了自适应 Hash。默认开启</p>
<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="hljs-string">&#x27;%adaptive_hash_index&#x27;</span>;</span><br></code></pre></td></tr></table></figure>

<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208282313307.png" srcset="/img/loading.gif" lazyload alt="image-20220828231324828"></p>
<hr>
<h2 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h2><p>如果我们利用二叉树作为索引结构,那么  <strong>磁盘的I0次数</strong>  和<code>索引树的高度是相关的</code>。</p>
<h2 id="1-二叉搜索树的特点"><a href="#1-二叉搜索树的特点" class="headerlink" title="1. 二叉搜索树的特点"></a>1. 二叉搜索树的特点</h2><ul>
<li>一个节点只能有两个子节点,也就是一个节点度不能超过2 【这里的度是出度】</li>
<li>左子节点&lt;本节点;</li>
<li>右子节点&gt;&#x3D;本节点</li>
</ul>
<p><strong>即：</strong>比我大的向右,比我小的向左</p>
<h2 id="2-查找规则"><a href="#2-查找规则" class="headerlink" title="2. 查找规则"></a>2. 查找规则</h2><p>我们先来看下最基础的二叉搜索树(Binary Search Tree),搜索某个节点和插入节点的规则一样,我们假设搜索插入的数值为key:</p>
<ol>
<li><p>如果key大于根节点,则在右子树中进行查找;</p>
</li>
<li><p>如果key小于根节点,则在左子树中进行查找;</p>
</li>
<li><p>如果key等于根节点,也就是找到了这个节点,返回根节点即可。</p>
</li>
</ol>
<p>举个例子,我们对数列(34, 22, 89,5, 23, 77, 91)创造出来的二分查找树如下图所示:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208292227476.png" srcset="/img/loading.gif" lazyload alt="image-20220829222731468"></p>
<hr>
<p>假设要找的是92，从根节点出发。比34大，找右子树。比89大，找右子树。比91大，但没有右子树，没找到。</p>
<p>时间复杂度是  <strong>O(log<del>2</del>^N^)</strong></p>
<p>但是存在特殊的情况,就是有时候二叉树的深度非常大。比如我们给出的数据顺序是(5,22, 23, 34, 77, 89, 91),创造出来的二分搜索树</p>
<p>如下图所示:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208292229088.png" srcset="/img/loading.gif" lazyload alt="image-20220829222929215"></p>
<hr>
<p>上面第二棵树也属于二分查找树,但是性能上已经退化成了一条链表,查找数据的时间复杂度变成了**0(n)**。</p>
<p>能看出来第一个树的深度是3,也就是说最多只需3次比较,就可以找到节点,而第二个树的深度是7,最多需要7次比较才能找到节点。</p>
<p>为了提高查询效率,就需要减少磁盘IO数。</p>
<p>为了减少磁盘10的次数,就需要尽量降低树的高度,需要把原来  <strong>“瘦高”的树结构</strong>  变的   **“矮胖” ** ，树的每层的分叉越多越好。</p>
<h2 id="6-4-AVL树"><a href="#6-4-AVL树" class="headerlink" title="6.4 AVL树"></a>6.4 AVL树</h2><p>为了解决上面二叉查找树退化成链表的问题,人们提出了平衡二叉搜索树(Balanced Binary Tree) ,又称为AVL树(<strong>有别于AVL算法</strong>)</p>
<p>它在二叉搜索树的基础上增加了约束,具有以下性质:</p>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1</p>
<p>并且左右两个子树都是一棵平衡二叉树。</p>
<p>这里说一下,常见的平衡二叉树有很多种,包括了平衡二叉搜索树、红黑树、数堆、伸展树。</p>
<p>平衡二叉搜索树是<strong>最早提出来</strong>的  <strong>自平衡</strong>  <strong>二叉搜索树</strong>,当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上,第一棵树就属于平衡二叉搜索树,搜索时间复杂度就是0(log2n)。</p>
<p>数据查询的时间主要依赖于磁盘1&#x2F;0的次数,如果我们采用二叉树的形式,即使通过平衡二叉搜索树进行了改进,树的深度也是 **O(log<del>2</del>^N^),**当n比较大时,深度也是比较高的</p>
<p>比如下图的情况:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208292239236.png" srcset="/img/loading.gif" lazyload alt="image-20220829223945040"></p>
<hr>
<p>每访问一次节点就需要进行一次磁盘 I&#x2F;0操作,对于上面的树来说,我们需要进行5次1&#x2F;0操作。</p>
<p>虽然平衡二叉树的效率高,但是树的深度也同样高,这就意味着磁盘1&#x2F;0操作次数多,会影响整体数据查询的效率。</p>
<p>针对同样的数据,如果我们把二叉树改成M叉树(M&gt;2)呢?当M&#x3D;3时,同样的31个节点可以由下面的三叉树来进行存储:</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208292240639.png" srcset="/img/loading.gif" lazyload alt="image-20220829224049269"></p>
<hr>
<p>你能看到此时树的高度降低了,当数据量N大的时候,以及树的分叉数M大的时候,M叉树的高度会远小于二叉树的高度(M&gt;2)。</p>
<p>所以,我们需要把树从“瘦高”变”矮胖”</p>
<h2 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h2><p>B树的英文是Balance Tree,也就是多路平衡查找树。简写为B-Tree (注意横杠表示这两个单词连起来的意思,不是减号)。它的高度<strong>远小于</strong>平衡二叉树的高度。</p>
<p>B 树的结构如下图所示：</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208292247508.png" srcset="/img/loading.gif" lazyload alt="image-20220829224753328"></p>
<hr>
<p>B树作为多路平衡查找树,它的  <strong>每一个节点</strong>  最多可以包括M个子节点,M称为B树的 <strong>阶</strong>。每个磁盘块中包括了关键字和子节点的指针。</p>
<p>如果一个磁盘块中包括了x个关键字,那么指针数就是x+1。对于一个100阶的B树来说,如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说,采用B树的结构是非常适合的,因为树的高度要远小于二叉树的高度。</p>
<p>举例：</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208292252067.png" srcset="/img/loading.gif" lazyload alt="image-20220829225236633"></p>
<hr>
<p>一个 M 阶的 B 树（M&gt;2）有以下的特性： </p>
<ol>
<li>根节点的儿子数的范围是 [2,M]。 </li>
<li>每个中间节点（非叶子节点）包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。 这里M&#x3D;3</li>
<li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。</li>
<li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]  P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。 5. 所有叶子节点位于同一层。</li>
</ol>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。 </p>
<p>然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步： </p>
<ol>
<li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </li>
<li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；</li>
<li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li>
</ol>
<p>能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。</p>
<p><strong>B 树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少</strong> ， 在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。</p>
<p>小结:</p>
<ol>
<li>B树在插入和删除节点的时候如果导致树不平衡,就通过自动调整节点的位置来保持树的 <strong>自平衡</strong>。</li>
<li>关键字集合分布在整棵树中,即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
<li><strong>B-Tree的完整的数据记录可能存在于非叶子节点中。</strong></li>
</ol>
<h2 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h2><p>B+树也是一种多路搜索树,基于B 树做出了改进,主流的DBMS都支持B+树的索引方式,比如MySQL。相比于B-Tree, <strong>B+Tree适合文件索引系统</strong>。</p>
<p><code>+</code>  : plus</p>
<p>MySQL官网说明：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">FIL_PAGE_PREV <span class="hljs-keyword">and</span> FIL_PAGE_NExT are the pag<span class="hljs-string">e&#x27;s &quot;backward&quot; and &quot;forward&quot; pointers. To show what they&#x27;</span>re about, l<span class="hljs-string">&#x27;ll draw a two-level B-tree.</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">FIL_PAGE_PREV和FIL_PAGE_NEXT是页面的“向后”和“向前”指针。为了显示它们的内容，这里将绘制一个两级<span class="hljs-selector-tag">B</span>树。<br></code></pre></td></tr></table></figure>

<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208292311023.png" srcset="/img/loading.gif" lazyload alt="image-20220829231114610"></p>
<hr>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Everyone has seen <span class="hljs-keyword">a</span> B-tree <span class="hljs-keyword">and</span> knows that <span class="hljs-keyword">the</span> entries <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> root page point <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> leaf pages.  (I indicate those pointers <span class="hljs-keyword">with</span> vertical <span class="hljs-string">&#x27;|&#x27;</span> bars <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> drawing.)  But sometimes people miss <span class="hljs-keyword">the</span> detail that leaf pages can also point <span class="hljs-built_in">to</span> <span class="hljs-keyword">each</span> other (I indicate those pointers <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> horizontal <span class="hljs-literal">two</span>-way pointer <span class="hljs-string">&#x27;&lt;-&gt;&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> drawing).  This feature allows InnoDB <span class="hljs-built_in">to</span> navigate <span class="hljs-built_in">from</span> leaf <span class="hljs-built_in">to</span> leaf <span class="hljs-keyword">without</span> having <span class="hljs-built_in">to</span> back up <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> root level.  This is <span class="hljs-keyword">a</span> sophistication which you won<span class="hljs-string">&#x27;t find in the classic B-tree, which is why InnoDB should perhaps be called a B+-tree instead.</span><br></code></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">每个人都看过<span class="hljs-selector-tag">B</span>树，并且知道根页面中的条目指向叶页面。(我在图中用竖线‘|’表示这些指针)。<br>但有时人们忽略了叶子页面也可以相互指向的细节(我在图中用水平双向指针‘&lt;-&gt;’来表示这些指针)。<br>此功能允许<span class="hljs-selector-tag">InnoDB</span>在叶与叶之间导航，而不必备份到根级别。这是您在经典的<span class="hljs-selector-tag">B</span>树中找不到的一种复杂性，这就是为什么<span class="hljs-selector-tag">InnoDB</span>可能应该被称为<span class="hljs-selector-tag">B</span>+树。<br></code></pre></td></tr></table></figure>





<p>B+ 树和 B 树的差异：</p>
<ol>
<li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1  </p>
</li>
<li><p>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。 </p>
</li>
<li><p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。</p>
</li>
<li><p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。</p>
</li>
</ol>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 </p>
<p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>
</blockquote>
<p>下图就是一棵B+树,阶数为3,根节点中的关键字1、18、35分别是子节点(1, 8, 14), (18, 24, 31)和(35, 41, 53)中的最小值。</p>
<p>每一层父节点的关键字都会出现在下一层的子节点的关键字中,因此在叶子节点中包括了所有的关键字信息,并且每一个叶子节点都有一个指向下一个节点的指针,这样就形成了一个链表。</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208312303582.png" srcset="/img/loading.gif" lazyload alt="image-20220831230337778"></p>
<hr>
<p>比如,我们想要查找关键字16, B+树会自顶向下逐层进行查找:</p>
<ol>
<li>与根节点的关键字(1, 18,35)进行比较,16在1和18之间,得到指针P1(指向磁盘块2)</li>
<li>找到磁盘块2,关键字为(1,8,14),因为16大于14,所以得到指针P3(指向磁盘块7)</li>
<li>找到磁盘块7,关键字为(14, 16, 17) ,然后我们找到了关键字16,所以可以找到关键字16所对应的数据。</li>
</ol>
<p>​	看起来B+树和B树的查询过程差不多,但是B+树和B树有个  <strong>根本的差异在于</strong>,”  <strong>B+树的中间节点并不直接存储数据</strong>”。这样的好处都有什么呢?</p>
<ul>
<li>首先,B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据,而在B树中,非叶子节点也会存储数据,这样就会造成查询效率不稳定的情况,有时候访问到了非叶子节点就可以找到关键字,而有时需要访问到叶子节点才能找到关键字。</li>
<li>其次,B+树的查询效率更高。这是因为通常B+树比B树更矮胖(阶数更大,深度更低),查询所需要的磁盘I&#x2F;0也会更少。同样的磁盘页大小,B+树可以存储更多的节点关键字。【B+Tree，完整的数据记录只会出现在叶子节点上，每个节点可以说是数据页16kb，只存某几个字段，会比存储整个数据记录能存储的更多，一个非叶子节点就可以连接更多的子节点，树更加 “矮胖”，IO次数更少】</li>
<li>不仅是对单个关键字的查询上,在  <strong>查询范围</strong>  上,B+树的效率也比B树高。这是因为所有关键字都出现在B+树的叶子节点中,叶子节点之间会有指针,数据又是递增的,这使得我们范围查找可以  <strong>通过指针连接</strong>  查找。而在B树中则需要通过  <strong>中序遍历  树</strong>  才能完成查询范围的查找,效率要低很多。</li>
</ul>
<p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong> </p>
<ol>
<li><p>数据库索引是存储在磁盘上的,如果数据量很大,必然导致索引的大小也会很大,超过几个G。</p>
</li>
<li><p>当我们利用索引查询时候,是  <strong>不可能</strong>   将全部几个G的索引都加载进内存的</p>
<p>我们能做的只能是:  <strong>逐一加载</strong>  <code>每一个磁盘页 </code> ,因为  <strong>磁盘页</strong>  对应着  <strong>索引树的节点</strong>   。</p>
</li>
</ol>
<p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong> </p>
<ul>
<li><p><code>InnoDB 存储引擎</code>  中  <code>页的大小为16KB</code>,一般表的主键类型为INT (占用4个字节)或BIGINT (占用8个字节),指针类型也一般为4或8个字节【指针指向数据页】,也就是说一个页(B+Tree中的一个节点)中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值(因为是估值,为方便计算,这里的K取值为10^3。^</p>
</li>
<li><p>就是说一个深度为3的B+Tree索引可以维护10^3^ X 10^3   X10^3^ &#x3D; 10亿条 记录。(这里假定一个  <strong>数据页也存储10^3^条</strong>行  记录数据了)实际情况中每个节点可能不能填充满,因此在数据库中 ,  <strong>B+Tree的高度</strong>  一般都在<code>2~4层</code>。</p>
</li>
<li><p>MySQL的  <strong>InnoDB 存储引擎</strong>  在设计时是将  <strong>根节点 常驻内存</strong>  的,也就是说查找某一键值的行记录时   最多只需要<strong>1-3次磁盘I&#x2F;0操作</strong>。</p>
</li>
</ul>
<p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<ol>
<li><p>B+树的磁盘读写代价更低</p>
<p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中,那么舟执所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
</li>
<li><p>B+树的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的结点,而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同,导致每一个数据的查询效率相当。</p>
</li>
</ol>
<p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong> </p>
<p>我们之前讲到过B+树索引的结构,Hash索引结构和B+树的不同,因此在索引使用上也会有差别。</p>
<ol>
<li><p>Hash索引不能进行  <strong>范围查询</strong>  ,而B+树可以。这是因为Hash索引指向的  <strong>数据是无序的</strong>  ,而B+树的  <strong>叶子节点是个有序的链表</strong>。</p>
</li>
<li><p>Hash索引不支持联合索引的最左侧原则(即联合索引的部分索引无法使用),而B+树可以。</p>
<p>对于联合索引来说,  <strong>Hash索引</strong>  在计算Hash值的时候是  将索引键   <strong>合并后再一起计算Hash值</strong>,  所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时,<strong>联合索引无法被利用</strong>。因此最左匹配也不会成功。</p>
</li>
<li><p>Hash索引  <strong>不支持 ORDER BY 排序</strong>,因为Hash索引指向的数据是无序的,因此无法起到排序优化的作用</p>
<p>而B+树索引数据是有序的,可以起到对该字段ORDER BY排序优化的作用。</p>
<p>同理,我们也无法用Hash索引进行模糊查询,而B+树使用LIKE进行模糊查询的时候,LIKE后面后模糊查询(比如%结尾)的话就可</p>
</li>
<li><p>InnoDb不支持Hash索引。</p>
</li>
</ol>
<p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</strong></p>
<p>如果使用的是MySQL的话,我们需要了解MySQL的存储引擎都支持哪些索引结构,如下图所示</p>
<p>(参考来源<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html">https://dev.mysql.com/doc/refman/8.0/en/create-index.html</a>) .如果是其他的DBMS, 可以参考相关的DBMS文档。</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208302320083.png" srcset="/img/loading.gif" lazyload alt="image-20220830232041391"></p>
<hr>
<p>你能看到,针对InnoDB和MyISAM 存储引擎,都会默认采用B+树索引,无法使用Hash索引。</p>
<p>InnoDB提供的自适应Hash是不需要手动指定的。如果是Memory&#x2F;Heap 和NDB存储引擎,是可以进行选择Hash索引的</p>
<h2 id="6-7-R树"><a href="#6-7-R树" class="headerlink" title="6.7 R树"></a>6.7 R树</h2><p>R-Tree在MySQL很少使用,  <code>仅支持geometry数据类型</code>  ),支持该类型的存储引Y只有myisam,bdb,innodb、ndb, archive几种。</p>
<p>举个R树在现实领域中能够解决的例子:查找20英里以内所有的餐厅。如果没有R树你会怎么解决?一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中,一个字段记录经度,另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息,然后计算是否满足要求。如果一个地区有100家餐厅的话,我们就要进行100次位置计算操作了,如果应用到谷歌、百度地图这种超大数据库中,这种方法便必定不可行了。</p>
<p>R树就很好的解决了这种  <strong>高维空间搜索问题</strong>。它把B树的思想很好的扩展到了多维空间,采用了B树分割空间的思想,</p>
<p>并在添加、删除操作时采用合并、分解结点的方法,保证树的平衡性。</p>
<p>因此 <strong>,R树</strong> 就是一棵用来存储  <strong>高维数据的平衡树</strong>  。相对于B-Tree, R-Tree的优势在于范围查找。</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202208302324471.png" srcset="/img/loading.gif" lazyload alt="image-20220830232419068"></p>
<hr>
<h2 id="6-8小结"><a href="#6-8小结" class="headerlink" title="6.8小结"></a>6.8小结</h2><ul>
<li><p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据,不过索引也存在一些不足,比如占用存储空间、降低数据库写操作的性能等,如果有多个索引还会增加索引选择的时间。当我们使用索引时,需要平衡索引的利(提升查询效率)和弊(维护索引所需的代价)。</p>
</li>
<li><p>在实际工作中,我们还需要基于需求和数据本身的分布情况来确定是否使用索引,尽  <strong>管索引不是万能的</strong>  ,但  <strong>数据量大</strong>  的时候  <strong>不使用索引是不可想象的</strong>  ,毕竟索<strong>引的本质,是帮助我们提升数据检索的效率</strong>。</p>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">视频学习笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-MySQL-%E9%AB%98%E7%BA%A7/">#尚硅谷-宋红康-MySQL(高级)</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>第06章-索引的数据结构-atguigu-shk</div>
      <div>http://example.com/2023/03/30/MySQL-宋红康-高级-第06章-索引的数据结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>March 30, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/30/MySQL-%E5%AE%8B%E7%BA%A2%E5%BA%B7-%E9%AB%98%E7%BA%A7-%E7%AC%AC05%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="第05章-存储引擎-atguigu-shk">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第05章-存储引擎-atguigu-shk</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/30/MySQL-%E5%AE%8B%E7%BA%A2%E5%BA%B7-%E9%AB%98%E7%BA%A7-%E7%AC%AC08%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="第08章-索引的创建与设计原则-atguigu-shk">
                        <span class="hidden-mobile">第08章-索引的创建与设计原则-atguigu-shk</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>WAITING</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
