

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、二分查找1.0算法描述 前提：有已排序数组 A（假设已经做好）  定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）  获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)  中间索引的值  A[M] 与待搜索的值 T 进行比较 ① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引 ② A[M] &gt; T，中间值右侧的其它元素都大于">
<meta property="og:type" content="article">
<meta property="og:title" content="基础篇">
<meta property="og:url" content="http://example.com/2023/03/30/itcast-%E5%9F%BA%E7%A1%80%E7%AF%87/index.html">
<meta property="og:site_name" content="FGCY-BLOG">
<meta property="og:description" content="一、二分查找1.0算法描述 前提：有已排序数组 A（假设已经做好）  定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）  获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)  中间索引的值  A[M] 与待搜索的值 T 进行比较 ① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引 ② A[M] &gt; T，中间值右侧的其它元素都大于">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/itcast.png">
<meta property="article:published_time" content="2023-03-30T09:56:52.000Z">
<meta property="article:modified_time" content="2023-03-31T06:02:07.711Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java基础-itcast">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/itcast.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>基础篇 - FGCY-BLOG</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":333,"cursorChar":"%","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>FGCY-BLOG</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>主页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签列表</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于我</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/playlist/">
                <i class="iconfont icon-music"></i>
                <span>音乐</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="基础篇"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-30 17:56" pubdate>
          March 30, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">基础篇</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h1><h3 id="1-0算法描述"><a href="#1-0算法描述" class="headerlink" title="1.0算法描述"></a>1.0<strong>算法描述</strong></h3><ol>
<li><p>前提：有已排序数组 A（假设已经做好）</p>
</li>
<li><p>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</p>
</li>
<li><p>获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)</p>
</li>
<li><p>中间索引的值  A[M] 与待搜索的值 T 进行比较</p>
<p>① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引</p>
<p>② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p>
<p>③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p>
</li>
<li><p>当 L &gt; R 时，表示没有找到，应结束循环</p>
</li>
</ol>
<span id="more"></span>

<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> t)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = a.length - <span class="hljs-number">1</span>, m;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        m = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (a[m] == t) &#123;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &gt; t) &#123;<br>            r = m - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l = m + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-0-解决溢出问题方式一："><a href="#2-0-解决溢出问题方式一：" class="headerlink" title="2.0 解决溢出问题方式一："></a>2.0 解决溢出问题方式一：</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ClassName: binarySearchDemo</span><br><span class="hljs-comment">     * Description:解决整数溢出的二分查找 方式一 数学运算</span><br><span class="hljs-comment">     * date:2022/3/18</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> fgcy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> JDK 1.8</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            System.out.println(<span class="hljs-string">&quot;比较&quot;</span> + ++counter + <span class="hljs-string">&quot;次&quot;</span>);<br>            <span class="hljs-comment">//int middle = (left + right)/2;//如果两个很大的数相加，有可能溢出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (target &gt; array[middle]) &#123;<br>                left = middle + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; array[middle]) &#123;<br>                right = middle - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//等跳出循环还没退出方法，说明没找到</span><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">33</span>, <span class="hljs-number">45</span>, <span class="hljs-number">46</span>, <span class="hljs-number">47</span>, <span class="hljs-number">88</span>, <span class="hljs-number">90</span>, <span class="hljs-number">99</span>&#125;;<br>        System.out.println(binarySearch1(ints, <span class="hljs-number">99</span>));<br>    &#125;<br>=============================================<br>比较<span class="hljs-number">1</span>次<br>比较<span class="hljs-number">2</span>次<br>比较<span class="hljs-number">3</span>次<br>比较<span class="hljs-number">4</span>次<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>



<h3 id="3-0-解决整数溢出方式二"><a href="#3-0-解决整数溢出方式二" class="headerlink" title="3.0 解决整数溢出方式二"></a>3.0 解决整数溢出方式二</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ClassName: binarySearchDemo</span><br><span class="hljs-comment">     * Description:解决整数溢出的二分查找 方式二 使用无符号右移一位【效率更高】</span><br><span class="hljs-comment">     * date:2022/3/18</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> fgcy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> JDK 1.8</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            System.out.println(<span class="hljs-string">&quot;比较&quot;</span> + ++counter + <span class="hljs-string">&quot;次&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">//无符号右移一位，相当于除以二且处于最高位的必为零</span><br>            <span class="hljs-keyword">if</span> (target &gt; array[middle]) &#123;<br>                left = middle + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; array[middle]) &#123;<br>                right = middle - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//等跳出循环还没退出方法，说明没找到</span><br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">33</span>, <span class="hljs-number">45</span>, <span class="hljs-number">46</span>, <span class="hljs-number">47</span>, <span class="hljs-number">88</span>, <span class="hljs-number">90</span>, <span class="hljs-number">99</span>&#125;;<br>        System.out.println(binarySearch2(ints, <span class="hljs-number">99</span>));<br>    &#125;<br>==================================================<br>比较<span class="hljs-number">1</span>次<br>比较<span class="hljs-number">2</span>次<br>比较<span class="hljs-number">3</span>次<br>比较<span class="hljs-number">4</span>次<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<h3 id="4-0-其它考法"><a href="#4-0-其它考法" class="headerlink" title="4.0 其它考法"></a>4.0 <strong>其它考法</strong></h3><ol>
<li><p>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 </p>
</li>
<li><p>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</p>
</li>
<li><p>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</p>
</li>
</ol>
<p>对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：</p>
<p>$$n &#x3D; log_2N &#x3D; log_{10}N&#x2F;log_{10}2$$</p>
<p>其中 n 为查找次数，N 为元素个数</p>
<h1 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h1><h3 id="0-0-算法描述"><a href="#0-0-算法描述" class="headerlink" title="0.0 算法描述"></a>0.0 <strong>算法描述</strong></h3><ol>
<li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li>
<li>重复以上步骤，直到整个数组有序</li>
</ol>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a.length - <span class="hljs-number">1</span>; j++) &#123;<br>        <span class="hljs-comment">// 一轮冒泡</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">swapped</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否发生了交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length - <span class="hljs-number">1</span> - j; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;比较次数&quot;</span> + i);<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[i + <span class="hljs-number">1</span>]) &#123;<br>                Utils.swap(a, i, i + <span class="hljs-number">1</span>);<br>                swapped = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;第&quot;</span> + j + <span class="hljs-string">&quot;轮冒泡&quot;</span><br>                           + Arrays.toString(a));<br>        <span class="hljs-keyword">if</span> (!swapped) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>优化点1：每经过一轮冒泡，内层循环就可以减少一次</li>
<li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环</li>
</ul>
<h3 id="1-0-方式一"><a href="#1-0-方式一" class="headerlink" title="1.0 方式一"></a>1.0 方式一</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"> 	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 优化一冒泡排序：</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">22</span>, <span class="hljs-number">7</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;原始数组是:&quot;</span> + Arrays.toString(arr));<br>        System.out.println(<span class="hljs-string">&quot;数组长度是&quot;</span> + arr.length + <span class="hljs-string">&quot;,理论上跑&quot;</span> + (arr.length - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;轮&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">//数组是否可以提前停止排序</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    swap(arr, j, j + <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">//当本轮没有发生过交换时说明已经有序可以提前结束，但本轮有交换，所以时不能停止</span><br>                    stop = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;轮：&quot;</span> + Arrays.toString(arr));<br>            <span class="hljs-comment">//只要这一轮没有交换过顺序，说明可以提前停止</span><br>            <span class="hljs-keyword">if</span> (stop) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;排序结果:&quot;</span> + Arrays.toString(arr));<br>    &#125;<br>=========================================================<br>原始数组是:[<span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">22</span>, <span class="hljs-number">7</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>]<br>数组长度是<span class="hljs-number">10</span>,理论上跑<span class="hljs-number">9</span>轮<br>第<span class="hljs-number">1</span>轮：[<span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">7</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>]<br>第<span class="hljs-number">2</span>轮：[<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>]<br>第<span class="hljs-number">3</span>轮：[<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>]<br>排序结果:[<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure>

<h3 id="2-0-方式二"><a href="#2-0-方式二" class="headerlink" title="2.0 方式二"></a>2.0 方式二</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 优化二冒泡排序：</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">22</span>, <span class="hljs-number">7</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;原始数组是:&quot;</span> + Arrays.toString(arr));<br>        System.out.println(<span class="hljs-string">&quot;数组长度是&quot;</span> + arr.length + <span class="hljs-string">&quot;,理论上跑&quot;</span> + (arr.length - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;轮&quot;</span>);<br>        <span class="hljs-comment">//第一轮需要比较全部的元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//当本轮已经有序了，不需要再进行排序了，此时通过将last的值0赋给n让排序终止</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>                    swap(arr, i, i + <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">//记录每次交换后的索引</span><br>                    last = i;<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (++counter) + <span class="hljs-string">&quot;轮：&quot;</span> + Arrays.toString(arr));<br>            <span class="hljs-comment">//将【最后】交换的索引给n，该索引往左的都是未排序的，右边都是已经有序的</span><br>            n = last;<br>            <span class="hljs-comment">//n会向0靠拢，当数组提前有序时，会有last=0赋给n，让其提前终止循环</span><br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;排序结果:&quot;</span> + Arrays.toString(arr));<br>    &#125;<br>===================================================<br>原始数组是:[<span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">22</span>, <span class="hljs-number">7</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>]<br>数组长度是<span class="hljs-number">10</span>,理论上跑<span class="hljs-number">9</span>轮<br>第<span class="hljs-number">1</span>轮：[<span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">7</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>]<br>第<span class="hljs-number">2</span>轮：[<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>]<br>第<span class="hljs-number">3</span>轮：[<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>]<br>排序结果:[<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>] <br></code></pre></td></tr></table></figure>

<h3 id="3-0-冒泡排序总结"><a href="#3-0-冒泡排序总结" class="headerlink" title="3.0 冒泡排序总结"></a>3.0 冒泡排序总结</h3><p>文字描述冒泡排序（以升序为例）<br>    依次比较数组中相邻的两个元素的大小，若arr[i]&gt;arr[i+1]，则交换两个元素；<br>    两两都比较一遍称为一轮冒泡，结果是让最大的元素拍到最后<br>    重复上述步骤，直至整个数组有序</p>
<p>优化方式<br>    每轮冒泡时，最后一次交换的索引作为下一轮冒泡的比较次数；若这个值为零时，表示整个数组有序，直接退出外层循环即可</p>
<h1 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h1><h3 id="1-0-算法描述"><a href="#1-0-算法描述" class="headerlink" title="1.0 算法描述"></a>1.0 <strong>算法描述</strong></h3><ol>
<li><p>将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</p>
</li>
<li><p>重复以上步骤，直到整个数组有序</p>
</li>
</ol>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">	 <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectedSort</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">21</span>, <span class="hljs-number">1</span>, <span class="hljs-number">65</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">55</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-comment">//i代表每轮所选择出的最小元素要交换到的目标索引【要把当前轮未排序区域的最小值放到该索引上】</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">//记录最小元素的索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s + <span class="hljs-number">1</span>; j &lt; array.length; j++) &#123;<br>                <span class="hljs-comment">//用当前轮目前的最小值，和未排序区的元素进行比较【是s不能是i】</span><br>                <span class="hljs-keyword">if</span> (array[s] &gt; array[j]) &#123;<br>                    <span class="hljs-comment">//得到每轮中比较出的最小值的索引</span><br>                    s = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//最小索引值与每轮想要交换到的目标索引相同时，说明不需要交换</span><br>            <span class="hljs-keyword">if</span> (i != s) swap(array, i, s);<br>            System.out.println(<span class="hljs-string">&quot;每轮所得到的数组：&quot;</span> + Arrays.toString(array));<br>        &#125;<br>        System.out.println(Arrays.toString(array));<br>    &#125;<br>=========================================================<br>每轮所得到的数组：[-<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">65</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">55</span>, <span class="hljs-number">0</span>, <span class="hljs-number">21</span>]<br>每轮所得到的数组：[-<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">65</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">55</span>, <span class="hljs-number">1</span>, <span class="hljs-number">21</span>]<br>每轮所得到的数组：[-<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">55</span>, <span class="hljs-number">65</span>, <span class="hljs-number">21</span>]<br>每轮所得到的数组：[-<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">55</span>, <span class="hljs-number">65</span>, <span class="hljs-number">21</span>]<br>每轮所得到的数组：[-<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">55</span>, <span class="hljs-number">65</span>, <span class="hljs-number">21</span>]<br>每轮所得到的数组：[-<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">21</span>, <span class="hljs-number">65</span>, <span class="hljs-number">55</span>]<br>每轮所得到的数组：[-<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">21</span>, <span class="hljs-number">55</span>, <span class="hljs-number">65</span>]<br>[-<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">21</span>, <span class="hljs-number">55</span>, <span class="hljs-number">65</span>] <br></code></pre></td></tr></table></figure>

<ul>
<li>选择排序思路</li>
</ul>
<p>将数组分为两个子集，已排序的与未排序的，每轮从未排序的自己中选出最小的元素，放在已排序的子集中<br>重复以上步骤，直至数组有序</p>
<ul>
<li>优化方式</li>
</ul>
<p>为减少交换次数，可以先记录最先元素的索引，再在每一轮的最后进行交换</p>
<h3 id="2-0与冒泡排序比较"><a href="#2-0与冒泡排序比较" class="headerlink" title="2.0与冒泡排序比较"></a>2.0与冒泡排序比较</h3><ol>
<li><p>二者平均时间复杂度都是 $O(n^2)$</p>
</li>
<li><p>选择排序一般要快于冒泡，因为其交换次数少</p>
</li>
<li><p>但如果集合有序度高，冒泡优于选择</p>
</li>
<li><p>冒泡属于稳定排序算法，而选择属于不稳定排序</p>
<ul>
<li>稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序</li>
<li>不稳定排序则反之</li>
</ul>
</li>
</ol>
<h1 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a>四、插入排序</h1><h3 id="1-0-算法描述-1"><a href="#1-0-算法描述-1" class="headerlink" title="1.0 算法描述"></a>1.0 <strong>算法描述</strong></h3><ol>
<li><p>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</p>
</li>
<li><p>重复以上步骤，直到整个数组有序</p>
</li>
</ol>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSorted</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">21</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">11</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<span class="hljs-comment">//待插入的元素值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<span class="hljs-comment">//已排序区域的索引</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (t &lt; arr[j]) &#123;<br>                    <span class="hljs-comment">//已取出的值，与有序区间的值进行比较，若有序区间的值较大则后移一位,直到有序值小于拿出的值，</span><br>                    <span class="hljs-comment">// 一旦发现取出的值大于有序的值则退出循环，如果一直没找到，就会空出索引为0的有序空间</span><br>                    arr[j + <span class="hljs-number">1</span>] = arr[j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//必须打破，有效率问题有算法问题（当没有移位时，不能索引减一）</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                j--;<br>            &#125;<br>            arr[j + <span class="hljs-number">1</span>] = t;<span class="hljs-comment">//将取出的值赋给空出的部分</span><br>            System.out.println(<span class="hljs-string">&quot;每轮排序的数组:&quot;</span> + Arrays.toString(arr));<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>===========================================<br>每轮排序的数组:[<span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">9</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">11</span>]<br>每轮排序的数组:[<span class="hljs-number">9</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">11</span>]<br>每轮排序的数组:[<span class="hljs-number">9</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">11</span>]<br>每轮排序的数组:[<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">11</span>]<br>每轮排序的数组:[-<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>]<br>每轮排序的数组:[-<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>]<br>[-<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>]<br><br>进程已结束，退出代码为 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (t &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>                    arr[j] = arr[j - <span class="hljs-number">1</span>];<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            arr[j] = t;<br>            System.out.println(<span class="hljs-string">&quot;每轮排序结果：&quot;</span> + Arrays.toString(arr));<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;最终排序结果：&quot;</span> + Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">2</span>, <span class="hljs-number">34</span>, <span class="hljs-number">21</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>&#125;;<br>        insertSorted(arr);<br>    &#125;<br>每轮排序结果：[<span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">2</span>, <span class="hljs-number">34</span>, <span class="hljs-number">21</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>]<br>每轮排序结果：[<span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">34</span>, <span class="hljs-number">21</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>]<br>每轮排序结果：[<span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">34</span>, <span class="hljs-number">21</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>]<br>每轮排序结果：[<span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">34</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>]<br>每轮排序结果：[<span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">34</span>, <span class="hljs-number">4</span>]<br>每轮排序结果：[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">34</span>]<br>最终排序结果：[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">34</span>]<br></code></pre></td></tr></table></figure>





<h3 id="2-0-与选择排序比较"><a href="#2-0-与选择排序比较" class="headerlink" title="2.0 与选择排序比较"></a>2.0 <strong>与选择排序比较</strong></h3><ol>
<li><p>二者平均时间复杂度都是 $O(n^2)$</p>
</li>
<li><p>大部分情况下，插入都略优于选择</p>
</li>
<li><p>有序集合插入的时间复杂度为 $O(n)$</p>
</li>
<li><p>插入属于稳定排序算法，而选择属于不稳定排序</p>
</li>
</ol>
<p><strong>提示</strong></p>
<blockquote>
<p><em>插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序</em></p>
</blockquote>
<h3 id="3-0-总结"><a href="#3-0-总结" class="headerlink" title="3.0 总结"></a>3.0 总结</h3><p>文字描述<br>    将数组分为两个区域，已排序与未排序，每一轮从未排序中取第一个元素，插入到有序区中（需要保证顺序）<br>    重复上述步骤，直至整个数组有序</p>
<p>优化方式<br>    在与待插入元素进行比较时，若发现有序区的元素比待插入元素小，就代表找到了插入元素，无需进行后续比较<br>    插入时直接移动元素，而不是交换元素</p>
<p>与选择相比较<br>    两者的平均复杂度都是O(n)的平方<br>    大部分情况下，插入优于选择<br>    有序插入的时间复杂度为O(n)的平方，有序冒泡也是O(n)的平方<br>    插入排序属于稳定排序，选择属于不稳定</p>
<h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">2</span>, <span class="hljs-number">34</span>, <span class="hljs-number">21</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>&#125;;<br>        XierSort(arr);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">XierSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (h &lt; n / <span class="hljs-number">2</span>) &#123;<br>            h = h * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (; h &gt; <span class="hljs-number">0</span>; h /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h; i &lt; n; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>                <span class="hljs-keyword">while</span> (j &gt;= h) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[j - h] &gt; t) &#123;<br>                        arr[j] = arr[j - h];<br>                        j -= h;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                arr[j] = t;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;每轮间隔下：&quot;</span> + Arrays.toString(arr));<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;最终结果：&quot;</span> + Arrays.toString(arr));<br>    &#125;<br><br>每轮间隔下：[<span class="hljs-number">4</span>, <span class="hljs-number">18</span>, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">21</span>, <span class="hljs-number">11</span>, <span class="hljs-number">34</span>]<br>每轮间隔下：[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">34</span>]<br>最终结果：[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">34</span>]<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> day01.sort;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShellSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;;<br>        shell_2(a);<br>    &#125;<br><br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shell_</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (h &lt; N / <span class="hljs-number">2</span>) &#123;<br>            h = <span class="hljs-number">2</span> * h + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h; i &lt; N; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= h; j -= h) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[j - h] &gt; arr[j]) &#123;<br>                        swap(arr, j, j - h);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            h /= <span class="hljs-number">2</span>;<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shell_2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (h &lt; N / <span class="hljs-number">2</span>) &#123;<br>            h = h * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h; i &lt; N; i++) &#123;<br>				<span class="hljs-comment">//j &gt;= h保证最小为零，不为负数                </span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= h; j -= h) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[j - h] &gt; arr[j]) &#123;<br>                        swap(arr, j - h, j);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            h /= <span class="hljs-number">2</span>;<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = t;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h1 id="六、快速排序"><a href="#六、快速排序" class="headerlink" title="六、快速排序"></a>六、快速排序</h1><h3 id="1-0-算法描述-2"><a href="#1-0-算法描述-2" class="headerlink" title="1.0 算法描述"></a>1.0 <strong>算法描述</strong></h3><ol>
<li>每一轮排序选择一个基准点（pivot）进行分区<ol>
<li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li>
<li>当分区完成时，基准点元素的位置就是其最终位置</li>
</ol>
</li>
<li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li>
<li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li>
</ol>
<h3 id="2-0-单边循环快排"><a href="#2-0-单边循环快排" class="headerlink" title="2.0 单边循环快排"></a>2.0 单边循环快排</h3><ol>
<li>选择最右边的元素作为基准点</li>
<li>j指针负责找到比基准点小的元素，一旦找到就与i进行交换</li>
<li>i指针维护小于基准点元素的边界，预计是每次交换的目标索引</li>
<li>最后基准点与i交换，i即为分区位置</li>
</ol>
<ul>
<li><p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p>
<ol>
<li><p>选择最右元素作为基准点元素</p>
</li>
<li><p>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换</p>
</li>
<li><p>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</p>
</li>
<li><p>最后基准点与 i 交换，i 即为分区位置</p>
</li>
</ol>
</li>
<li><p>代码实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.find;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSortDemo</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> t1, <span class="hljs-type">int</span> t2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[t1];<br>        array[t1] = array[t2];<br>        array[t2] = temp;<br>    &#125;<br><br>    <span class="hljs-comment">//每次调用都会两边都找一下</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= h) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> quickSort(arr, l, h);<br>        quick(arr, l, i - <span class="hljs-number">1</span>);<br>        quick(arr, i + <span class="hljs-number">1</span>, h);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-comment">//基准点元素(最后一个元素)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> arr[h];<br>        <br>        <span class="hljs-comment">//i,j一开始都是区间最左边的元素，i负责维护小于基准点的元素的边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>        <br>        <span class="hljs-comment">//j的范围是从区间最左边到基准点元素(区间最右)，找到比基准点元素小的就与i的值进行交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> l; j &lt; h; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; pv) &#123;<br>                <span class="hljs-keyword">if</span> (i != j) &#123;<br>                    swap(arr, i, j);<br>                &#125;<br>                <span class="hljs-comment">//更换边界值索引，往右移是因为当前索引所知的值已经与j的值进行交换比基准点小</span><br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != h) &#123;<span class="hljs-comment">//当边界值与基准元素是同一个时，不交换</span><br>            swap(arr, i, h);<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        quick(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br>==================================<br>[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure>



<h3 id="3-0-双边快排"><a href="#3-0-双边快排" class="headerlink" title="3.0 双边快排"></a>3.0 双边快排</h3><p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p>
<ol>
<li>选择最左元素作为基准点元素</li>
<li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li>
<li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li>
</ol>
<p>要点</p>
<ol>
<li><p>基准点在左边，并且要先 j 后 i</p>
</li>
<li><p>while( <strong>i</strong> **&lt; j** &amp;&amp; a[j] &gt; pv ) j– </p>
</li>
<li><p>while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] <strong>&lt;&#x3D;</strong> pv ) i++</p>
</li>
<li><p>选择最左边元素作为基准点元素</p>
</li>
<li><p>j指针负责从右向左找比基准点小的元素，i指针负责从右往左找比基准点大的元素，一旦找到两者交换，直至i，j相交</p>
</li>
<li><p>最后基准点与i（此时i与j相等）交换，i极为分区位置</p>
</li>
</ol>
<ul>
<li>几个要点</li>
</ul>
<ol>
<li>基准点在左边，并且要先j后i</li>
<li>while(i&lt;j &amp;&amp; a[j]&gt;pv) j–;</li>
<li>while(i&lt;j &amp;&amp; a[i]&gt;&#x3D;pv) i++;</li>
</ol>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.sort;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSortDemo2</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> t1, <span class="hljs-type">int</span> t2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[t1];<br>        array[t1] = array[t2];<br>        array[t2] = temp;<br>    &#125;<br><br>    <span class="hljs-comment">//每次调用都会两边都找一下</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-comment">//当区间中只有一个元素时</span><br>        <span class="hljs-keyword">if</span> (l &gt;= h) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> quickSort(arr, l, h);<br>        <span class="hljs-comment">//对左边分区进行排序</span><br>        quick(arr, l, i - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//对右边分区进行排序</span><br>        quick(arr, i + <span class="hljs-number">1</span>, h);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-comment">//取区间最左边的值作为基准值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> arr[l];<br>        <span class="hljs-comment">//i为区间左边第一个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>        <span class="hljs-comment">//j为区间右边第一个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> h;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         *先从j开始找，找到比基准值小的就记录下索引值；否则j--</span><br><span class="hljs-comment">         * 再从i开始找，找到比基准值大的就记录下索引；否则i++</span><br><span class="hljs-comment">         * 交换i，j两个索引处的值当他们相遇时，就退出循环</span><br><span class="hljs-comment">         * 交换基准值和i所对应的值</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pv) j--;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pv) i++;<br>            swap(arr, i, j);<br>        &#125;<br>        swap(arr, j, l);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        quick(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br>======================================================<br>[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure>

<ul>
<li>快速排序特点</li>
</ul>
<ol>
<li>平均时间复杂度：O(n log2 n次方)，最坏时间复杂度：O(n 2平方)</li>
<li>数据量大时，优势特别明显</li>
<li>属于不稳定排序（选择排序）</li>
</ol>
<p><strong>快排特点</strong></p>
<ol>
<li><p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$</p>
</li>
<li><p>数据量较大时，优势非常明显</p>
</li>
<li><p>属于不稳定排序</p>
</li>
</ol>
<h1 id="七、集合"><a href="#七、集合" class="headerlink" title="七、集合"></a>七、集合</h1><h2 id="1-0-ArrayList的扩容机制"><a href="#1-0-ArrayList的扩容机制" class="headerlink" title="1.0 ArrayList的扩容机制"></a>1.0 ArrayList的扩容机制</h2><ul>
<li>​	<strong>扩容规则</strong></li>
</ul>
<ol>
<li><p>ArrayList() 会使用长度为零的数组</p>
</li>
<li><p>ArrayList(int initialCapacity) 会使用指定容量的数组，扩容机制&gt;&gt;&gt;1.5</p>
</li>
<li><p>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</p>
</li>
<li><p>add(Object o) 首次扩容为 <code>10</code>，再次扩容为上次容量的 1.5 倍</p>
</li>
<li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p>
</li>
</ol>
<blockquote>
<p> 其中第 4 点必须知道，其它几点视个人情况而定</p>
</blockquote>
<ul>
<li><p>ArrayList的初始容量</p>
<p>使用无参构造的方法:容量是零(长度为零的对象数组)<br>使用一个int类型作为入参的构造方法:容量是入参(长度为入参长的对象数组)<br>使用一个集合类型作为入参的构造方法：容量是集合的大小</p>
</li>
<li><p>add()扩容</p>
<p>当使用ArrayList的无参构造创建对象时，会给分配一个长度为零的数组，当加入第一个元素时，会创建一个长度为10的数组(扩容)，这个数组会替换掉原来的空数组； </p>
<p>当加入第十一个元素时【要插入的元素下标等于数组大小】，ArrayList又进行扩容，为原来的1.5倍(创建一个长度为15的数组，将原来数组的元素拷贝到新数组中)，原来的数组因为没有引用指向，会被gc干掉；</p>
<p>当加入第16个元素时，ArrayList又进行扩容，将15&gt;&gt;&gt;1 &#x3D;7,15+7&#x3D;22;创建一个长度为22的数组，将原来数组的元素拷贝到新数组中，原来的数组因为没有引用指向，会被gc干掉；</p>
</li>
<li><p>addAll()扩容</p>
</li>
</ul>
<ol>
<li>现在集合中元素个数为零，下一次会扩容为10，添加一个元素个数小于等于10的集合，此时该集合扩容为10；</li>
<li>现在集合中元素个数为零，下一次会扩容为10，添加一个元素个数为22的集合，此时该集合扩容为22；Math.max(10,22)</li>
<li>现在集合中元素个数为11个，下一次会扩容为22 ，添加一个元素个数为10的集合（此时所有元素个数为21&lt;22），此时该集合扩容为22；Math.max(21,22)</li>
</ol>
<ul>
<li>扩容机制</li>
</ul>
<ol>
<li>ArrayList() 无参构造会使用长度为零的数组</li>
<li>ArrayList(int initialCapacity)会使用指定容量的数组，但是扩容是懒惰式的的，即在没有添加元素前，即使制定了长度，也不会创建数组</li>
<li>public ArrayList(Collection&lt;? extends E&gt; c)会使用c的大小作为数组容量</li>
<li>add(Object o)首次扩容为十，再次扩容为原来的1.5倍（先右移一位，再加上原来数组的长度）</li>
<li>addAll(Conllection c)没有元素时，扩容为Math.max(10,实际元素个数)，有元素时为Math.max(原容量的1.5倍，实际元素个数)</li>
</ol>
<p><strong>首先，通过无参构造创建一个ArrayList对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">arrayList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br></code></pre></td></tr></table></figure>



<p>底层原理：调用无参构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">//常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的值为“&#123;&#125;”，为空数组</span><br></code></pre></td></tr></table></figure>

<p>即使用ArrayList创建ArrayList对象时，并没有初始化底层数组elementData，等到调用add(E e) 方法的时候再初始化elementData，这种”懒加载”模式可以节省内存。</p>
<p><strong>调用add(E e) 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">arrayList.add(<span class="hljs-string">&quot;test&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>底层原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-comment">// 确认elementData容量是否足够</span><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 第一次调用add()方法时，size=0</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>





<p>先调用<code>ensureCapacityInternal</code>(int minCapacity) 方法,对数组容量进行检查，不够时则进行扩容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当当前集合的数组为“&#123;&#125;”时，初始化容量，</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    	<span class="hljs-comment">//即第一次调用add(E e)， 如果elementData为&quot;&#123;&#125;&quot;,重新定义minCapacity的值，赋值为DEFAULT_CAPACITY=10</span><br>    	<span class="hljs-comment">// 即第一次调用add(E e)方法时，定义底层数组elementData的长度为10</span><br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br>		<span class="hljs-comment">// 判断是否需要扩容</span><br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure>



<p>ensureExplicitCapacity(minCapacity) 判断是否需要扩容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        modCount++;<br>	<br>        <span class="hljs-comment">// 第一次进入时，minCapacity=10,elementData.length=0,对数组进行扩容</span><br>        <span class="hljs-comment">// 之后再进入时，minCapacity=size+1，elementData.length=10(每次扩容后会改变)，</span><br>        <span class="hljs-comment">// 需要minCapacity&gt;elementData.length成立，才能扩容</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            grow(minCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure>



<p>grow(minCapacity) 对数组进行扩容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// 将数组长度赋值给oldCapacity</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    	<br>    	<span class="hljs-comment">// 将oldCapacity右移一位再加上oldCapacity，即相当于newCapacity=1.5oldCapacity(不考虑精度损失)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    	<br>    	<span class="hljs-comment">// 如果newCapacity还是小于minCapacity，直接将minCapacity赋值给newCapacity</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>    <br>    <span class="hljs-comment">// 特殊情况：newCapacity的值过大，直接将整型最大值赋给newCapacity，</span><br>	<span class="hljs-comment">// 即newCapacity=Integer.MAX_VALUE</span><br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// 将elementData的数据拷贝到扩容后的数组</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br><span class="hljs-comment">// 如果大于临界值，进行整型最大值的分配</span><br><span class="hljs-comment">//private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>            Integer.MAX_VALUE :<br>            MAX_ARRAY_SIZE;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>结论：</p>
<p>使用ArrayList()创建ArrayList对象时，不会定义底层数组的长度，当第一次调用add(E e) 方法时，初始化定义底层数组的长度为10，之后调用add(E e)时，如果需要扩容，则调用grow(int minCapacity) 进行扩容,长度为原来的1.5倍。</p>
<p>ArrayList还有有参构造器：ArrayList(int initialCapacity) 和 ArrayList(Collection&lt;? extends E&gt; c)，前则创建可以指定初始容量的集合，后者创建一个包含指定collection元素的集合，两者的底层数组初始化和扩容机制与上述ArrayList()一样，且添加方法add(int index, E e)和add(E e)的扩容机制一样。</p>
<h2 id="2-0-Iterator的fail-fast、fail-safe"><a href="#2-0-Iterator的fail-fast、fail-safe" class="headerlink" title="2.0 Iterator的fail-fast、fail-safe"></a>2.0 Iterator的fail-fast、fail-safe</h2><p>Fail-Fast 与 Fail-Safe</p>
<ul>
<li><p><code>ArrayList </code>    <code>Vector</code>是 fail-fast 的典型代表，<strong>遍历的同时不能修改</strong>，尽快失败</p>
</li>
<li><p><code>CopyOnWriteArrayList </code>是 fail-safe 的典型代表，<strong>遍历的同时可以修改</strong>，原理是读写分离</p>
</li>
</ul>
<p><strong>fail-fast</strong></p>
<p>ArrayList时fail-fast的典型代表，遍历的同时不能修改，否则抛错，尽快失败<br>一旦发现遍历的时候别人来修改，立即抛异常</p>
<p>并发修改异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">final</span> ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;A&quot;</span>));<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;B&quot;</span>));<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;C&quot;</span>));<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;D&quot;</span>));<br>    <br>    <span class="hljs-comment">//调用增强for循环时，底层调用的是iterator迭代器</span><br>    <span class="hljs-keyword">for</span> (Student student : list) &#123;<br>        list.remove(student);  <span class="hljs-comment">//java.util.ConcurrentModificationException</span><br>        System.out.println(student);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//集合中 通过方法返回一个迭代器对象给增强for</span><br><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<span class="hljs-comment">//会调用成员内部类的无参构造</span><br>&#125;<br><br>  <span class="hljs-comment">//成员内部类</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>        <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>     <br>     	<span class="hljs-comment">//modCount是ArrayList的实例成员变量，记录当前ArrayList实例被修改的次数</span><br>     	<span class="hljs-comment">//expectedModCount是迭代器实例维护的实例成员变量，记录一开始获得数组时，数组被修改的次数；</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>        Itr() &#123;&#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//下一个元素的下标不等于该集合的大小</span><br>            <span class="hljs-keyword">return</span> cursor != size;<br>        &#125;<br><br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            checkForComodification();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>            <span class="hljs-keyword">if</span> (i &gt;= size)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            cursor = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>        &#125;<br>     <br>     <br>     <br>     <span class="hljs-comment">//-----------------------------------------------------------------</span><br>     <span class="hljs-comment">//每次取出元素时都会查看集合是否被修改了，若改了就抛异常</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        &#125;<br><br></code></pre></td></tr></table></figure>





<p><strong>fail-save</strong></p>
<p>发现遍历的时候有人来修改，会采取一些策略，例如：<strong>牺牲一致性</strong>来让整个遍历完成<br><code>CopyOnWriteArrayList</code>是<code> fail-safe</code> 的典型代表，遍历的同时可以修改，<strong>原理是读写分离</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">@Test<br>public void test2()&#123;<br>    final CopyOnWriteArrayList&lt;Student&gt; list = new CopyOnWriteArrayList&lt;&gt;();<br>    list.add(new Student(&quot;A&quot;));<br>    list.add(new Student(&quot;B&quot;));<br>    list.add(new Student(&quot;C&quot;));<br>    list.add(new Student(&quot;D&quot;));<br><br>    //增强for底层调用迭代器<br>    for (Student student : list) &#123;<br>        list.remove(student);<br>        System.out.println(student);<br>    &#125;<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Student&#123;name:<span class="hljs-string">&#x27;A&#x27;</span>&#125;<br>Student&#123;name:<span class="hljs-string">&#x27;B&#x27;</span>&#125;<br>Student&#123;name:<span class="hljs-string">&#x27;C&#x27;</span>&#125;<br>Student&#123;name:<span class="hljs-string">&#x27;D&#x27;</span>&#125;<br><span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="hljs-number">0</span>);<br>   &#125;<br><br><span class="hljs-comment">//返回当前实例的数组，用于在迭代器中也维护一份（集合中每次添加新的元素就会创建一个长度+1的数组，将原数组的值复制到新数组中，	并将新数组作为底层数组），这样修改集合中的元素，对迭代器没有影响</span><br>   <span class="hljs-keyword">final</span> Object[] getArray() &#123;<br>       <span class="hljs-keyword">return</span> array;<br>   &#125;<br></code></pre></td></tr></table></figure>



<p>对集合进行修改时，先复制出一份，再进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>      lock.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>          Object[] elements = getArray();<br>          <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>          Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>          newElements[len] = e;<br>          setArray(newElements);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          lock.unlock();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>CopyOnWriteArrayList的读写分离，弱一致性</p>
</blockquote>
<h2 id="3-0-LinkedList和ArrayList"><a href="#3-0-LinkedList和ArrayList" class="headerlink" title="3.0 LinkedList和ArrayList"></a>3.0 LinkedList和ArrayList</h2><p><strong>LinkedList</strong></p>
<ol>
<li>基于双向链表，无需连续内存</li>
<li>随机访问慢（要沿着链表遍历）</li>
<li><strong>头尾插入 删除</strong>性能高</li>
<li>占用内存多</li>
</ol>
<p><strong>ArrayList</strong></p>
<ol>
<li>基于数组，需要连续内存</li>
<li>随机访问快（指根据下标访问）</li>
<li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li>
<li>可以利用 cpu 缓存 –&gt; 局部性原理</li>
</ol>
<p>两者比较：<br>    ArrayList</p>
<ol>
<li><p>基于数组，需要连续内存</p>
</li>
<li><p>随机访问快【根据下标访问】（根据数组地址，元素类型，索引综合计算）直接得到想要访问元素的地址</p>
</li>
<li><p>尾部插入、删除性能尚可；其他地方插入、删除需要移动元素，性能较低(尤其是头部)【<strong>综合性能ArrayList要优于LinkedList</strong>】</p>
</li>
<li><p>可以利用cpu缓存(cpu与内存之间访问所需的时间较长，所以使用cpu缓存，来提升读写性能)，局部性原理(访问一个数据的时候，</p>
<p>cpu会默认认为它附近的元素有很大概率会被访问，所以一并加载进cpu缓存)</p>
</li>
</ol>
<p>LinkedList</p>
<ol>
<li>基于双向链表，无需连续内存</li>
<li>随机访问慢（需要沿着链表遍历）</li>
<li>头尾插入性能较高，容易查到【查询中间元素，性能略低于ArrayList】</li>
<li>内存占用多（除了要存储对象地址外，还需要存储头节点地址，尾节点地址，头部节点和尾部节点）</li>
</ol>
<h1 id="八、HashMap"><a href="#八、HashMap" class="headerlink" title="八、HashMap"></a>八、HashMap</h1><h2 id="1-0-基本数据结构"><a href="#1-0-基本数据结构" class="headerlink" title="1.0 基本数据结构"></a>1.0 基本数据结构</h2><ul>
<li>1.7 数组 + 链表</li>
<li>1.8 数组 + （链表 | 红黑树）</li>
</ul>
<h2 id="2-0-树化与退化"><a href="#2-0-树化与退化" class="headerlink" title="2.0 树化与退化"></a>2.0 树化与退化</h2><p><strong>树化意义</strong></p>
<ul>
<li>红黑树用来避免 <code>DoS </code> 攻击，防止链表超长时性能下降，树化应当是 偶然情况，是保底策略</li>
<li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 O(log⁡2N )，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li>
<li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 <code>0.75 </code>的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li>
</ul>
<p><strong>树化规则</strong></p>
<ul>
<li>当 <strong>链表长度</strong> 超过  <strong>树化阈值 8</strong> 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li>
</ul>
<p><strong>退化规则</strong></p>
<ul>
<li>情况1：在扩容时如果  <strong>拆分树</strong> 时，<strong>树元素个数 &lt;&#x3D; 6</strong> 则会退化链表</li>
<li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li>
</ul>
<h2 id="3-0-索引计算"><a href="#3-0-索引计算" class="headerlink" title="3.0 索引计算"></a>3.0 索引计算</h2><p><strong>索引计算方法</strong></p>
<ul>
<li>首先，计算对象的 hashCode()</li>
<li>再进行调用 HashMap 的 hash() 方法进行二次哈希<ul>
<li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li>
</ul>
</li>
<li>最后 二次hash值 &amp; (capacity – 1) 得到索引 <strong>hash%tab.length</strong>等价于<strong>hash&amp;(tab.lenngth-1)</strong></li>
</ul>
<p><strong>数组容量为何是 2 的 n 次幂</strong></p>
<ol>
<li>计算索引时效率更高：如果是 2 的 n 次幂可以使用 <strong>位与运算</strong> 代替取模</li>
<li>扩容时重新计算索引效率更高： <strong>hash &amp; oldCap</strong> &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>二次 hash 是为了配合 <strong>容量是 2 的n次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li>
<li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 <code>Hashtable</code></li>
</ul>
<h2 id="4-0-put-与扩容"><a href="#4-0-put-与扩容" class="headerlink" title="4.0 put 与扩容"></a>4.0 put 与扩容</h2><p><strong>put 流程</strong></p>
<ol>
<li>HashMap 是懒惰创建数组的，首次使用才创建数组</li>
<li>计算索引（桶下标）</li>
<li>如果桶下标还没人占用，创建 Node 占位返回</li>
<li>如果桶下标已经有人占用<ol>
<li>已经是 TreeNode 走红黑树的添加或更新逻辑</li>
<li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li>
</ol>
</li>
<li>返回前检查容量是否超过阈值，一旦超过进行扩容</li>
</ol>
<p><strong>1.7 与 1.8 的区别</strong></p>
<ol>
<li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p>
</li>
<li><p>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</p>
</li>
<li><p>1.8 在扩容计算 Node 索引时，会优化</p>
</li>
</ol>
<p><strong>扩容（加载）因子为何默认是 0.75f</strong></p>
<ol start="2">
<li>大于这个值，空间节省了，但链表就会比较长影响性能</li>
<li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li>
</ol>
<blockquote>
<p> 在空间占用与查询时间之间取得较好的权衡</p>
</blockquote>
<h2 id="5-0-并发问题"><a href="#5-0-并发问题" class="headerlink" title="5.0 并发问题"></a>5.0 并发问题</h2><p><strong>扩容死链（1.7 会存在）</strong></p>
<p>1.7 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-type">boolean</span> rehash)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123;<br>            Entry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-keyword">if</span> (rehash) &#123;<br>                e.hash = <span class="hljs-literal">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity);<br>            e.next = newTable[i];<br>            newTable[i] = e;<br>            e = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>数据错乱（1.7，1.8 都会存在）</strong></li>
</ul>
<p>​		多线程下put()元素导致元素缺失</p>
<h2 id="6-0-key-的设计"><a href="#6-0-key-的设计" class="headerlink" title="6.0 key 的设计"></a>6.0 key 的设计</h2><ul>
<li><strong>key 的设计要求</strong></li>
</ul>
<ol>
<li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li>
<li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li>
<li>key 的 hashCode 应该有良好的散列性</li>
</ol>
<ul>
<li><p><strong>String 对象的 hashCode() 设计</strong></p>
<ul>
<li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li>
<li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 </li>
<li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li>
<li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 <ul>
<li>即 $32 ∗h -h $</li>
<li>即 $2^5  ∗h -h$</li>
<li>即 $h≪5  -h$</li>
</ul>
</li>
<li>想要散列效果较好就选择，是奇数的素数</li>
</ul>
</li>
<li><p>底层结构，1.7与1.8有什么不同</p>
</li>
</ul>
<p>1.7: </p>
<pre><code class="hljs">  1. 数组 + 链表
  2. 链表插入节点时使用头插法
  3. 当前元素个数大于等于阈值(当前数组长度的四分之三)且要插入的元素的桶下标对应的位置有元素时，才进行扩容；
  4. 扩容后，要迁移元素；计算Node桶下标时没有优化（二次hash值 &amp; oldCapacity == 0则不用移动；否则移动到新的桶下标位置去 新位置=当前桶下标+oldCacity）
</code></pre>
<p>1.8: </p>
<pre><code class="hljs"> 1.  数组 + 链表(或红黑树)
 2.  链表插入节点时使用尾插法
 3.  当前元素个数大于等于阈值【当前数组长度的四分之三】时，扩容；
 4.  扩容后，要迁移元素；计算Node桶下标时有优化（二次hash值 &amp; oldCapacity == 0则不用移动；否则移动到新的桶下标位置去 新位置=当前桶下+oldCacity）
</code></pre>
<ul>
<li><p><strong>modecount的作用</strong></p>
<p>HashMap时线程不安全的<br>每修改一次hashMap对象，modcount就会+1；</p>
<p>当使用迭代器遍历时，它会记录下当前的modcount数量【expextedModcount】，每次取下一个元素时就会，就会判断expectModcount与modcount是否相等，不相等，就并发修改异常</p>
</li>
<li><p>1.7</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> 算桶下标<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br>    	<span class="hljs-comment">//HashMap的Entry数组长度必须是  non-zero power of 2</span><br>    	<span class="hljs-comment">//hashCode和数组长度减一按位与；数组长度减一是桶下标范围；</span><br>        <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-number">2.</span> 使用无参构造实例HashMap<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-comment">//默认初始化长度1&lt;&lt;4,加载因子0.75</span><br>        <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);<br>    &#125;<br><br><span class="hljs-number">3.</span> put方法<br>        <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    	<span class="hljs-comment">//判读数组是不是之前的空数组</span><br>    	<span class="hljs-comment">//static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;数组一开始是长度为0的数组</span><br>    	<span class="hljs-comment">// transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br>        <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>            <span class="hljs-comment">//数组是长度为0的数组，就创建一个长度不为零的数组</span><br>            inflateTable(threshold);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> putForNullKey(value);<br>    	<span class="hljs-comment">//二次hash</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    	<span class="hljs-comment">//算桶下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>     	<span class="hljs-comment">//遍历链表，添加元素时，如果发现链表中的键与新加的键相同时，旧值返回，新值替换旧值</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>            Object k;<br>            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                e.value = value;<br>                e.recordAccess(<span class="hljs-built_in">this</span>);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>		<span class="hljs-comment">//修改次数</span><br>        modCount++;<br>        addEntry(hash, key, value, i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><span class="hljs-number">4.</span> 头插法<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">createEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>        Entry&lt;K,V&gt; e = table[bucketIndex];<br>    	<span class="hljs-comment">//创建一个新的Entry对象，它的next是当前桶下标的数组中的引用，接着将将自己的引用赋给当前桶下标的数组</span><br>        table[bucketIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<br>    	<span class="hljs-comment">//当前总元素个数+1</span><br>        size++;<br>    &#125;<br>    <br><span class="hljs-number">5.</span> 初始化数组大小 【当put元素时，才会创建有大小的数组】<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inflateTable</span><span class="hljs-params">(<span class="hljs-type">int</span> toSize)</span> &#123;<br>        <span class="hljs-comment">// Find a power of 2 &gt;= toSize</span><br>    	<span class="hljs-comment">//找到一个大于等于2的n次方数的数</span><br>    	<span class="hljs-comment">//toSize是调用构造时传入的初始化参数，无参时默认16</span><br>    	<span class="hljs-comment">//数组长度一定时 2的幂次方数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> roundUpToPowerOf2(toSize);<br>		<span class="hljs-comment">//扩容阈值</span><br>        threshold = (<span class="hljs-type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>        table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[capacity];<br>        initHashSeedAsNeeded(capacity);<br>    &#125;<br>    <br><span class="hljs-number">6.</span> hashMap扩容<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>    	<span class="hljs-comment">//threshold通过加载因子和数组长度计算出的扩容阈值</span><br>    	<span class="hljs-comment">//如果插入的桶下标中为null，即使现在已经满了阈值也不扩容【1.7】</span><br>        <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-literal">null</span> != table[bucketIndex])) &#123;<br>            <span class="hljs-comment">//扩容为原来的两倍</span><br>            resize(<span class="hljs-number">2</span> * table.length);<br>            hash = (<span class="hljs-literal">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;<br>            bucketIndex = indexFor(hash, table.length);<br>        &#125;<br><br>        createEntry(hash, key, value, bucketIndex);<br>    &#125;<br><br><span class="hljs-number">7.</span> 扩容<br>    <br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;<br>        Entry[] oldTable = table;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>        <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>		<span class="hljs-comment">//两倍长度数组</span><br>        Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newCapacity];<br>    	<span class="hljs-comment">//元素转移</span><br>        transfer(newTable, initHashSeedAsNeeded(newCapacity));<br>        table = newTable;<br>        threshold = (<span class="hljs-type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>    &#125;<br><br><br><span class="hljs-number">8.</span> 元素转移<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    新数组下标有两种情况： 原来的桶下标；原来的桶下标+原来数组长度</span><br><span class="hljs-comment">    */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-type">boolean</span> rehash)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    	<span class="hljs-comment">//遍历Entry数组</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br>                <span class="hljs-keyword">if</span> (rehash) &#123;<br>                    e.hash = <span class="hljs-literal">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);<br>                &#125;<br>                <br>                <span class="hljs-comment">//得到新的桶下标，原来的hashCode新的数组长度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity);<br>                <span class="hljs-comment">//【1.7】头插法，新数组桶下标中的引用作为要转移元素的下一个元素</span><br>                e.next = newTable[i];<br>                <span class="hljs-comment">//要转移的元素作为桶下标中的引用</span><br>                newTable[i] = e;<br>                <span class="hljs-comment">//在链表中下移</span><br>                e = next;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-number">9.</span> 判断是否要rehash<br>    <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initHashSeedAsNeeded</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    	<span class="hljs-comment">//hashSeed默认为零</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">currentAltHashing</span> <span class="hljs-operator">=</span> hashSeed != <span class="hljs-number">0</span>;<span class="hljs-comment">//false</span><br>    	<span class="hljs-comment">//jvm是否启动</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">useAltHashing</span> <span class="hljs-operator">=</span> sun.misc.VM.isBooted() &amp;&amp;<br>            	<span class="hljs-comment">//当前数组容量是否大于某个值 默认整形最大 可以通过配置jvm参数改变</span><br>                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);<br>    	<span class="hljs-comment">//异或 不同为真 useAltHashing一定为真</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">switching</span> <span class="hljs-operator">=</span> currentAltHashing ^ useAltHashing;<br>        <span class="hljs-keyword">if</span> (switching) &#123;<br>            hashSeed = useAltHashing<br>                ? sun.misc.Hashing.randomHashSeed(<span class="hljs-built_in">this</span>)<br>                : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> switching;<br>    &#125;<br><br><span class="hljs-number">10</span> <br>    <br>    <br><span class="hljs-number">11.</span> 多线程扩容时形成死链<br></code></pre></td></tr></table></figure>



<ul>
<li>为什么要用红黑树</li>
</ul>
<p>当链表过长时，访问的效率会变低；而红黑树增删查改性能较高，当链表长度过长时，对查询性能的影星不大</p>
<ul>
<li>为什么不直接红黑树</li>
</ul>
<p>一般情况下，元素在哈希表中存储呈现泊松分布，很少有较长的链表；<br>在链表较短的情况下，查询的性能要优于红黑树；只有在链表很长的情况下，性能才远远不如红黑树<br>红黑树较于链表来说需要花费更大的存储空间；TressNode占用的空间比Node要大，所以，如非必要，尽量不要使用红黑树<br>树化是一种特殊情况，使用红黑树是为了避免被DOS攻击后导致链表过长使得查询性能降低；</p>
<ul>
<li>红黑树的阈为什么是8</li>
</ul>
<p>当hash值足够随机时，元素在hash表内呈现泊松分布，在负载因子0.75的情况下，长度超过8的链表出现的概率为0.00000006<br>选择8是为了让树化的概率足够小</p>
<ul>
<li>什么时候会转成红黑树</li>
</ul>
<p>当链表的长度大于8时，会先判断当前数组长度，如果数组长度小于64，则进行扩容；<br>当链表的长度大于8时，且数组长度大于等于64，此时会将链表转化为红黑树</p>
<ul>
<li>什么时候会退化成链表</li>
</ul>
<p>​	两种情况：</p>
<pre><code class="hljs">1. 在扩容时，如果发生拆分树的情况，当树元素个数小于等于6时，就会退化成链表
   【当当前的数组所有元素个数大于当前数组长度的四分之三时，数组会扩容为原来的两倍】当移除树的节点时，若root、root.left、root.right、root.left.left有一个为null时，会退化成链表
</code></pre>
<ul>
<li>索引值如何计算</li>
</ul>
<ol>
<li>首先调用对象的hashCode方法得到原始hash，再通过HashMap的hash方法对原始hash进行计算得到二次hash;</li>
<li>最后通过二次hash的值对当前数组长度取模获取索引值（桶下标）【这种是方便人计算，当数组容量是2的n次幂时，走的是下面 按位与的方式，效率更高】</li>
</ol>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">97 </span>% <span class="hljs-number">16</span> =<span class="hljs-number">1</span>  <span class="hljs-number">97</span>&amp;(<span class="hljs-number">16</span>-<span class="hljs-number">1</span>)=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<p>二次hash值 &amp; （capacity-1）；注意：capacity的值必须是二的几次幂的形式</p>
<ul>
<li>HashMap中的hash</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当hashCode非空时，将原来的hashcode右移十六位取高位十六位，再与原来的hashCode作异或运算    </span><br><span class="hljs-comment">//二次hash的好处，使得元素在数组中的分布尽可能随机</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>       <span class="hljs-type">int</span> h;<br>       <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>二次hash的目的</li>
</ul>
<p>​		二次hash是为了综合高位数据，使得元素分布更加均匀</p>
<ul>
<li>数组容量为何是2的n次幂</li>
</ul>
<ol>
<li><p>计算索引时，如果使用的是2的n次幂的形式，那么取模运算可以用按位与来替代，效率更高；</p>
</li>
<li><p>扩容时，如果 (hash &amp; oldCapacity) &#x3D;&#x3D;  ，否则到新的位置（新位置&#x3D;旧位置+oldCapacity）</p>
</li>
<li><p>如果数组采用的是2的n次幂作为容量时，说明更加看重性能（与上面的1 2配合使用);如果采用质数作为数组容量，则hash分布更加均匀；不能说那种设计更优，这是设计者综	合各种因素最终选择使用2的n次幂作为数组容量</p>
</li>
</ol>
<ul>
<li>put方法流程，1.7、1.8有何不同</li>
</ul>
<ol>
<li>HashMap是懒惰创建数组，首次使用put添加元素时才创建数组；</li>
<li>计算索引（桶下标）【通过key的值得到hashCode，再通过HashMap的hash方法对hashCode进行计算得到二次hash的值，将 二次hash值 &amp; (capacity-1)】</li>
<li>如果桶下标没人占用，创建Node节点占用</li>
<li>如果桶下标已经有人占用，分两种情况：<br>一：已经是TreeNode，走红黑树的添加或更新逻辑(equals比较相同)<br>二：是普通Node节点，走链表的更新(equals比较相同)或添加逻辑，当链表过长时就进行树化(链表长度是否大于8 &amp;&amp; 数组长度是否大于等于16)</li>
<li>添加元素后判断当前总元素个数是否大于当前数组长度的四分之三，一旦超过就扩容</li>
</ol>
<ul>
<li>加载因子为何默认是0.75f</li>
</ul>
<ol>
<li>在空间占用与查询时间之间取得了较好的平衡</li>
<li>大于这个值，空间节省了，但不能即时扩容会导致链表可能过长，影响查询性能；</li>
<li>小于这个值，冲突减少了(链表长度可能会减少)，但空间频繁扩容，空间占用多</li>
</ol>
<ul>
<li>Key是否能为null，作为key的对象有什么要求？</li>
</ul>
<ol>
<li>HashMap的key可以为null，但Map的其他实现类则不然 concurrentHashMap、HashTable、TreeMap；</li>
<li>作为key的对象必须实现hashCode和equals</li>
<li>key的内容不可以修改</li>
</ol>
<ul>
<li>String对象的hashCode如何设计？为什么每次乘以31？</li>
</ul>
<p>任何对象的hashCode都应该足够独特，目标为达到较为均匀的散列效果<br> hashCode设计：</p>
<pre><code class="hljs">1. 字符串中的每个字符都可以表现为一个数字，称为Si，i的范围是 0到n-1，n是元素个数
2. 代入散列公式： 

S0*31^ n-1+S1*31^ n-2+s3*31^N-3+...&quot;123456&quot; 49*31^5 + 50*31^4 + 51*31^3 + 52*31^2 + 53*31^1 + 54*31^0

3. `  31`  代入公式有较好的散列特性，并且算数可以优化 31x = (32-1)x = 32x-x = 2^5x-x = x&lt;&lt;5-x
</code></pre>
<ul>
<li><p>多线程下操作HahMap</p>
</li>
<li><ul>
<li>问题一（数据错乱）：并发丢失数据</li>
</ul>
</li>
<li><ul>
<li>问题二：死链</li>
</ul>
</li>
</ul>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/202210101009630.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h1 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h1><h2 id="1-0-饿汉懒汉区别"><a href="#1-0-饿汉懒汉区别" class="headerlink" title="1.0 饿汉懒汉区别"></a>1.0 饿汉懒汉区别</h2><p>饿汉本质是在静态代码块中调用私有构造；所以一碰到类就会初始化</p>
<p>懒汉本质就是不在静态代码块中，调用私有构造</p>
<h2 id="2-0-饿汉单例"><a href="#2-0-饿汉单例" class="headerlink" title="2.0 饿汉单例"></a>2.0 饿汉单例</h2><h3 id="2-1-饿汉单例-反射破坏单例-预防"><a href="#2-1-饿汉单例-反射破坏单例-预防" class="headerlink" title="2.1 饿汉单例 (反射破坏单例+预防)"></a>2.1 饿汉单例 (反射破坏单例+预防)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.design_pattern;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ClassName: SingletonDemo1</span><br><span class="hljs-comment"> * Description:饿汉式单例</span><br><span class="hljs-comment"> * date:2022/3/19</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fgcy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> JDK 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonDemo1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SingletonDemo1</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonDemo1</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonDemo1</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">//预防反射破坏单例</span><br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;the instance is already exist&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;无参构造&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;otherMethods()&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSingleton</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//调用类的静态方法，使得SingletonDemo1这个类 加载、连接、初始化</span><br>        <span class="hljs-comment">//也就是静态常量SingletonDemo1对象被创建</span><br>        SingletonDemo1.otherMethod();<br>        System.out.println(SingletonDemo1.getInstance());<br>        System.out.println(SingletonDemo1.getInstance());<br><br><br>        <span class="hljs-comment">//1. 反射破坏单例</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            reflection(SingletonDemo1.class);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reflection</span><span class="hljs-params">(Class&lt;SingletonDemo1&gt; clazz)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> Constructor&lt;SingletonDemo1&gt; constructor = clazz.getDeclaredConstructor();<br>        <span class="hljs-comment">//暴力反射</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;通过反射获取的实例&quot;</span> + constructor.newInstance());<br>    &#125;<br>&#125;<br>==================反射破坏单例===============<br>无参构造<br>otherMethods()<br>com.itheima.design_pattern.SingletonDemo1@330bedb4<br>com.itheima.design_pattern.SingletonDemo1@330bedb4<br>无参构造<span class="hljs-comment">//反射调用构造器获取对象</span><br>通过反射获取的实例com.itheima.design_pattern.SingletonDemo1@2503dbd3<br>=====================预防反射破坏单例==================<br>无参构造<br>otherMethods()<br>com.itheima.design_pattern.SingletonDemo1@330bedb4<br>com.itheima.design_pattern.SingletonDemo1@330bedb4<br>java.lang.reflect.InvocationTargetException<br>Caused by: java.lang.RuntimeException: the instance is already exist<br></code></pre></td></tr></table></figure>





<h3 id="2-2-饿汉单例-反序列化破坏单例-预防"><a href="#2-2-饿汉单例-反序列化破坏单例-预防" class="headerlink" title="2.2 饿汉单例 (反序列化破坏单例+预防)"></a>2.2 饿汉单例 (反序列化破坏单例+预防)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.design_pattern;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ClassName: SingletonDemo1</span><br><span class="hljs-comment"> * Description:饿汉式单例</span><br><span class="hljs-comment"> * date:2022/3/19</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fgcy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> JDK 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//当希望该类的对象可以转为字节保存在磁盘中或进行网络传输时，实现序列化接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonDemo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SingletonDemo2</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonDemo2</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonDemo2</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">//预防反射破坏单例</span><br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;the instance is already exist&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;无参构造&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;otherMethods()&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-comment">//预防反序列化破化单例</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSingleton</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//调用类的静态方法，使得SingletonDemo1这个类 加载、连接、初始化</span><br>        <span class="hljs-comment">//也就是静态常量SingletonDemo1对象被创建</span><br>        SingletonDemo1.otherMethod();<br>        System.out.println(SingletonDemo2.getInstance());<br>        System.out.println(SingletonDemo2.getInstance());<br><br>        <span class="hljs-comment">//2.反序列化破坏单例</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            serializable(SingletonDemo2.getInstance());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//2.反序列化破坏单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serializable</span><span class="hljs-params">(SingletonDemo2 instance)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>        oos.writeObject(instance);<br>        <span class="hljs-comment">//字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray()));<br>        <span class="hljs-comment">//反序列化创建对象，不走构造器，直接从文件中生成</span><br>        System.out.println(ois.readObject());<br>    &#125;<br><br>&#125;<br><br>====================反序列化破坏单例======================<br>无参构造<br>otherMethods()<br>无参构造<br>com.itheima.design_pattern.SingletonDemo2@330bedb4<br>com.itheima.design_pattern.SingletonDemo2@330bedb4<br>com.itheima.design_pattern.SingletonDemo2@7b23ec81<span class="hljs-comment">//不通过构造器获得新对象</span><br>====================预防反序列化破坏单例======================<br>无参构造<br>otherMethods()<br>无参构造<br>com.itheima.design_pattern.SingletonDemo2@330bedb4<br>com.itheima.design_pattern.SingletonDemo2@330bedb4<br>com.itheima.design_pattern.SingletonDemo2@330bedb4    <br></code></pre></td></tr></table></figure>





<h3 id="2-3-unSave破坏单例"><a href="#2-3-unSave破坏单例" class="headerlink" title="2.3 unSave破坏单例"></a>2.3 unSave破坏单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.design_pattern;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ClassName: SingletonDemo1</span><br><span class="hljs-comment"> * Description:饿汉式单例</span><br><span class="hljs-comment"> * date:2022/3/19</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fgcy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> JDK 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonDemo3</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SingletonDemo3</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonDemo3</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;otherMethods()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSingleton</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//调用类的静态方法，使得SingletonDemo1这个类 加载、连接、初始化</span><br>        <span class="hljs-comment">//也就是静态常量SingletonDemo1对象被创建</span><br>        SingletonDemo1.otherMethod();<br>        System.out.println(SingletonDemo3.getInstance());<br>        System.out.println(SingletonDemo3.getInstance());<br><br>        <span class="hljs-comment">//unsave破坏单例</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> getUnsafe().allocateInstance(SingletonDemo3.class);<br>            System.out.println(instance);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ClassName: TestSingleton</span><br><span class="hljs-comment">     * Description:通过反射获取Unsave实例</span><br><span class="hljs-comment">     * date:2022/3/19</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> fgcy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> JDK 1.8</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            <span class="hljs-comment">//因为 Unsafe 的 theUnsafe 字段是private 的，所以这里需要设置成可访问的</span><br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">//Unsafe 的这个属性 theUnsafe 是静态的所以这里的get参数就是null</span><br>            <span class="hljs-comment">//因为get(Object obj))是获取某个实例的属性，类属性属于类不属于实例，实例只是共享</span><br>            <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">return</span> unsafe;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br>===============Unsave破坏单例（无解）========================<br>无参构造<br>otherMethods()<br>无参构造<br>com.itheima.design_pattern.SingletonDemo3@330bedb4<br>com.itheima.design_pattern.SingletonDemo3@330bedb4<br>com.itheima.design_pattern.SingletonDemo3@4b67cf4d<br></code></pre></td></tr></table></figure>







<h2 id="3-0-枚举饿汉式"><a href="#3-0-枚举饿汉式" class="headerlink" title="3.0 枚举饿汉式"></a>3.0 枚举饿汉式</h2><h3 id="3-1-认识枚举类"><a href="#3-1-认识枚举类" class="headerlink" title="3.1 认识枚举类"></a>3.1 认识枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.design_pattern;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sex</span> &#123;<br>    MALE, FEMALE;<br>&#125;<br>----------------------------------<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span>&lt;Sex&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sex</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> ordinal)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, ordinal);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        MALE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sex</span>(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);<br>        FEMALE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sex</span>(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    ........<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="3-2枚举类实现饿汉式单例"><a href="#3-2枚举类实现饿汉式单例" class="headerlink" title="3.2枚举类实现饿汉式单例"></a>3.2枚举类实现饿汉式单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.design_pattern;<br><br><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><br><span class="hljs-comment">//枚举实现饿汉式单例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">EnumSingletonTest</span> &#123;<br>    INSTANCE;<br><br>    <span class="hljs-comment">//枚举的构造都是私有的，所以这里可以省略private，但不是包权限</span><br>    <span class="hljs-comment">//java语言的内置规范.枚举类没有&lt;init&gt;无参构造</span><br>    EnumSingletonTest() &#123;<br>        System.out.println(<span class="hljs-string">&quot;private EnumSingletonTest()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;public static void otherMethod()&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//需要重写toString；不然会打印 ”INSTANCE“</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(<span class="hljs-built_in">this</span>.hashCode());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EnumSingletonTest <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEnum</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        EnumSingletonTest.otherMethod();<br>        System.out.println(EnumSingletonTest.getInstance());<br>        System.out.println(EnumSingletonTest.getInstance());<br>        System.out.println(<span class="hljs-string">&quot;Unsave破坏单例&quot;</span> + getUnsafe().allocateInstance(EnumSingletonTest.class));<br>        <br>        <span class="hljs-comment">//反序列化破坏单例</span><br>        <span class="hljs-comment">//失败--》【ObjectInputStream会对枚举类做出识别，不会从文件中生成对象】</span><br>        serializable(EnumSingletonTest.getInstance());<br><br>        <span class="hljs-comment">//反射破坏单例</span><br>        <span class="hljs-comment">//失败</span><br>        <span class="hljs-comment">// com.itheima.design_pattern.EnumSingletonTest.&lt;init&gt;()没有无参构造报错</span><br>        <span class="hljs-comment">// Cannot reflectively create enum objects枚举类不能通过反射获取对象</span><br>        reflection(EnumSingletonTest.class);<br>    &#125;<br><br><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            <span class="hljs-comment">//因为 Unsafe 的 theUnsafe 字段是private 的，所以这里需要设置成可访问的</span><br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">//Unsafe 的这个属性 theUnsafe 是静态的所以这里的get参数就是null</span><br>            <span class="hljs-comment">//因为get(Object obj))是获取某个实例的属性，类属性属于类不属于实例，实例只是共享</span><br>            <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">return</span> unsafe;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//通过反序列化获取EnumSingletonTest实例方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serializable</span><span class="hljs-params">(EnumSingletonTest instance)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>        oos.writeObject(instance);<br>        <span class="hljs-comment">//字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中</span><br>        <span class="hljs-comment">//ObjectOutputStream会特殊处理枚举类，返回的式枚举类的实例，而不是文件中的字节数组生成的实例</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray()));<br>        System.out.println(<span class="hljs-string">&quot;反序列化破坏单例&quot;</span> + ois.readObject());<br>    &#125;<br><br>    <span class="hljs-comment">//通过反射获取EnumSingletonTest实例方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reflection</span><span class="hljs-params">(Class&lt;EnumSingletonTest&gt; clazz)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> Constructor&lt;EnumSingletonTest&gt; constructor = clazz.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class);<br>        <span class="hljs-comment">//暴力反射</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//没有无参构造报错</span><br><span class="hljs-comment">//        System.out.println(&quot;通过反射获取的实例&quot; + constructor.newInstance());</span><br>        <span class="hljs-comment">//枚举类不能通过反射获取对象</span><br><span class="hljs-comment">//        System.out.println(&quot;通过反射获取的实例&quot; + constructor.newInstance(&quot;OTHER&quot;, 3));</span><br>    &#125;<br>&#125;<br>=====================================================<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">EnumSingletonTest</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span><span class="hljs-comment">//运行静态方法前先跑静态代码块的内容，即先创建对象（饿汉式）</span><br>com.itheima.design_pattern.EnumSingletonTest@330bedb4<br>com.itheima.design_pattern.EnumSingletonTest@330bedb4<br>Unsave破坏单例com.itheima.design_pattern.EnumSingletonTest@4b67cf4d<span class="hljs-comment">//可以破坏</span><br>反序列化破坏单例com.itheima.design_pattern.EnumSingletonTest@330bedb4<span class="hljs-comment">//不可以破坏</span><br></code></pre></td></tr></table></figure>





<h2 id="4-0-懒汉单例"><a href="#4-0-懒汉单例" class="headerlink" title="4.0 懒汉单例"></a>4.0 懒汉单例</h2><h3 id="4-1-双检锁懒汉式"><a href="#4-1-双检锁懒汉式" class="headerlink" title="4.1 双检锁懒汉式"></a>4.1 双检锁懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.design_pattern;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.regexp.internal.RE;<br><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sluggard</span> &#123;<br><br>    <span class="hljs-comment">//静态变量，属于类</span><br>	<span class="hljs-comment">//private static Sluggard INSTANCE;</span><br>    <span class="hljs-comment">//volatile 共享变量，可见性，有序性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Sluggard INSTANCE;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sluggard</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;private Sluggard()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 这种方式获取实例，没有线程安全性</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sluggard <span class="hljs-title function_">getInstance1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//当多个线程第一次在还没有创建实例时就都来到这一步时，就会创建多个实例，破坏单例</span><br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sluggard</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 通过加锁的方式实现线程安全</span><br><span class="hljs-comment">     * 这里的锁对象时Sluggard.class</span><br><span class="hljs-comment">     * 当多个线程同时到达这个方法的外部时，只有一个线程可以获得锁进入方法，其他线程挂起</span><br><span class="hljs-comment">     * 当混进方法的线程执行完逻辑后，其他线程再竞争锁，进入方法，就会发现已有实例，不需要创建</span><br><span class="hljs-comment">     * 但这个方法有问题:每个线程调用该方法都要等待锁（即使此时，已有实例）</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Sluggard <span class="hljs-title function_">getInstance2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sluggard</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 解决上面方法的效率问题</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 双检锁懒汉式</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sluggard <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//4.此时实例不为空，就不会存在线程不安全的问题</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//1.当多个线程第一次在还没有创建实例时就都来到这一步时</span><br>            <span class="hljs-comment">//2.多个线程竞争锁</span><br>            <span class="hljs-keyword">synchronized</span> (Sluggard.class) &#123;<br>                <span class="hljs-comment">//3.第一个竞争到锁的线程创建了实例，在外面等锁的线程，进来之后就不会创建实例</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sluggard</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot; public static void otherMethod()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSingleton1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//先调用静态方法，如果是饿汉式，就会调用无参构造获取实例【加载 连接初 始化】</span><br>        Sluggard.otherMethod();<br>        System.out.println(Sluggard.getInstance());<br>        System.out.println(Sluggard.getInstance());<br>    &#125;<br>&#125;<br>===================================================================<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span><span class="hljs-comment">//懒汉式，调用静态方法没有触发初始化</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Sluggard</span><span class="hljs-params">()</span><br>com.itheima.design_pattern.Sluggard@330bedb4<br>com.itheima.design_pattern.Sluggard@330bedb4<br></code></pre></td></tr></table></figure>





<h3 id="4-2-为什么要添加valatile修饰符"><a href="#4-2-为什么要添加valatile修饰符" class="headerlink" title="4.2 为什么要添加valatile修饰符"></a>4.2 为什么要添加valatile修饰符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主要是为了防止指令重排</span><br><br><span class="hljs-comment">//反编译字节码文件查看文件执行指令顺序</span><br>D:\learn\tencentClass\interview\ChanzPodcast\base\Project\out\production\one\com\itheima\design_pattern&gt;javap -c -v -p Sluggard.class<br><br> 		<span class="hljs-number">17</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// class com/itheima/design_pattern/Sluggard</span><br>        <span class="hljs-number">20</span>: dup<br>        <span class="hljs-number">21</span>: invokespecial #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">24</span>: putstatic     #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Field INSTANCE:Lcom/itheima/design_pattern/Sluggard;</span><br>	<span class="hljs-comment">//第17指令，创建对象；在堆内存中开辟出一块空间，根据Sluggard实例的成员变量和方法引用，计算出空间大小；【创建对象就是分配空间】</span><br>    <span class="hljs-comment">//第21指令，调用构造器，为成员变量初始化(没有就赋默认值)</span><br>    <span class="hljs-comment">//第24指令，给静态变量赋值，将创建好的Sluggard对象赋值给静态变量        </span><br></code></pre></td></tr></table></figure>

<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202210232303927.png" srcset="/img/loading.gif" lazyload alt="image-20221023230321856"></p>
<hr>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202210232304585.png" srcset="/img/loading.gif" lazyload alt="image-20221023230413726"></p>
<hr>
<ul>
<li>小结</li>
</ul>
<p>为什么懒汉单例没有线程安全问题<br>    静态成员变量在定义的同时赋值，这个赋值操作(给静态成员变量赋值)是会放在该类的静态代码块中；<br>    静态代码块中的线程安全，是由jvm负责的</p>
<h3 id="4-3-内部类实现懒汉单例"><a href="#4-3-内部类实现懒汉单例" class="headerlink" title="4.3 内部类实现懒汉单例"></a>4.3 内部类实现懒汉单例</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.design_pattern;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ClassName: InnerClassSingleton</span><br><span class="hljs-comment"> * Description:内部类实现懒汉单例</span><br><span class="hljs-comment"> * date:2022/3/20</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fgcy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> JDK 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClassSingleton</span> &#123;<br>	<br>    <span class="hljs-comment">//私有构造</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">InnerClassSingleton</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;private InnerClassSingleton()&quot;</span>);<br>    &#125;<br>	<span class="hljs-comment">//静态方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;private static void otherMethod()&quot;</span>);<br>    &#125;<br>	<span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>        <span class="hljs-comment">//内部类可以访问外部类的所有成员（本类中）</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">InnerClassSingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClassSingleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InnerClassSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//静态内部类属于外部类，所以通过外部类类名调用，又因为是在本类，所以可以省略外部类类名</span><br>		<span class="hljs-comment">//return InnerClassSingleton.InnerClass.INSTANCE;</span><br>        <span class="hljs-comment">//碰到类的时候，就会加载静态代码块中的内容（又由于是在静态代码块中，线程是安全的）</span><br>        <span class="hljs-keyword">return</span> InnerClass.INSTANCE;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        InnerClassSingleton.otherMethod();<br>        System.out.println(<span class="hljs-string">&quot;..........................&quot;</span>);<br>        System.out.println(InnerClassSingleton.getInstance());<br>        System.out.println(InnerClassSingleton.getInstance());<br>    &#125;<br>&#125;<br>=======================================<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span><span class="hljs-comment">//InnerClassSingleton实例的创建在内部类中，这里只是调用了外部类的方法，没有碰到内部类，所以不会调用无参构造</span><br>..........................<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">InnerClassSingleton</span><span class="hljs-params">()</span><br>com.itheima.design_pattern.InnerClassSingleton@330bedb4<br>com.itheima.design_pattern.InnerClassSingleton@330bedb4<br></code></pre></td></tr></table></figure>



<h2 id="5-0-jdk有哪些地方体现单例"><a href="#5-0-jdk有哪些地方体现单例" class="headerlink" title="5.0 jdk有哪些地方体现单例"></a>5.0 jdk有哪些地方体现单例</h2><ul>
<li>双检锁懒汉式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">   System.java<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Console</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Console <span class="hljs-title function_">console</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (cons == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (System.class) &#123;<br>                cons = sun.misc.SharedSecrets.getJavaIOAccess().console();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cons;<br>    &#125;<br></code></pre></td></tr></table></figure>





<ul>
<li>饿汉式单例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;<br>    <span class="hljs-comment">//在静态代码块中实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br>	<span class="hljs-comment">//提供一个对外访问的入口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br>	<span class="hljs-comment">//私有构造</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-comment">//退出虚拟机的方法，非零代表异常退出</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> &#123;<br>      <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">security</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;<br>            security.checkExit(status);<br>        &#125;<br>        Shutdown.exit(status);<br>    &#125;<br>    <span class="hljs-comment">//告诉虚拟机要做一次垃圾回收</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gc</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>





<ul>
<li>内部类懒汉式单例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>	<span class="hljs-keyword">static</span> class &lt;E&gt;&#123;<br>        <span class="hljs-comment">//内部类的内部类</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptyNavigableSet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnmodifiableNavigableSet</span>&lt;E&gt;<br>            <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>   			<span class="hljs-comment">//防止反序列化破坏单例</span><br>            <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span>&#123; <span class="hljs-keyword">return</span> EMPTY_NAVIGABLE_SET; &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//当有人碰到UnmodifiableNavigableSet时，才会触发初始化</span><br>        <span class="hljs-comment">//EmptyNavigableSet的静态成员变量</span><br>        <span class="hljs-meta">@SuppressWarnings(&quot;rawtypes&quot;)</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> NavigableSet&lt;?&gt; EMPTY_NAVIGABLE_SET =<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyNavigableSet</span>&lt;&gt;();<br>    <br>     <span class="hljs-comment">//UnmodifiableNavigableSet类返回EmptyNavigableSet单例的方法</span><br>     <span class="hljs-comment">//EmptyNavigableSet的静态成员方法</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; NavigableSet&lt;E&gt; <span class="hljs-title function_">emptyNavigableSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (NavigableSet&lt;E&gt;) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;<br>    &#125;   <br>&#125;<br>     <span class="hljs-comment">//Collections的静态成员方法</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; SortedSet&lt;E&gt; <span class="hljs-title function_">emptySortedSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (SortedSet&lt;E&gt;) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure>





<ul>
<li>饿汉单例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-comment">//在外部类中创建内部类对象不用带类名</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Set</span> <span class="hljs-variable">EMPTY_SET</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptySet</span>&lt;&gt;();<br>    <br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;T&gt; Set&lt;T&gt; <span class="hljs-title function_">emptySet</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> (Set&lt;T&gt;) EMPTY_SET;<br>     &#125;<br>    <br>    <span class="hljs-comment">//静态内部类（使用默认的公开无参构造，但外部类无法访问，私有的内部类）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptySet</span>&lt;E&gt;&#123;&#125;<br>        <br> &#125;<br></code></pre></td></tr></table></figure>





<ul>
<li>枚举饿汉式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;   <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">naturalOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//调用枚举方法创造的实例</span><br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;<br>    &#125;  <br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparators</span> &#123;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">NaturalOrderComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Comparable&lt;Object&gt;&gt; &#123;<br>        INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>JDK 中单例的体现</strong></p>
<ul>
<li><code>Runtime </code>   体现了饿汉式单例</li>
<li><code>Console </code>  体现了双检锁懒汉式单例</li>
<li><code>Collections </code> 中的 EmptyNavigableSet 内部类懒汉式单例</li>
<li><code>ReverseComparator.REVERSE_ORDER</code> 内部类懒汉式单例</li>
<li><code>Comparators.NaturalOrderComparator.INSTANCE</code> 枚举饿汉式单例</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">视频学习笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java%E5%9F%BA%E7%A1%80-itcast/">#java基础-itcast</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>基础篇</div>
      <div>http://example.com/2023/03/30/itcast-基础篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>March 30, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/30/itcast-%E5%B9%B6%E5%8F%91%E7%AF%87/" title="并发篇">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">并发篇</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/30/itcast-%E6%A1%86%E6%9E%B6%E7%AF%87/" title="框架篇">
                        <span class="hidden-mobile">框架篇</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      

    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>WAITING</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
