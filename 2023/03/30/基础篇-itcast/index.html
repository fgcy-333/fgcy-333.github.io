<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>基础篇-itcast | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、二分查找1.0算法描述 前提：有已排序数组 A（假设已经做好）  定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）  获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)  中间索引的值  A[M] 与待搜索的值 T 进行比较 ① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引 ② A[M] &gt; T，中间值右侧的其它元素都大于">
<meta property="og:type" content="article">
<meta property="og:title" content="基础篇-itcast">
<meta property="og:url" content="http://example.com/2023/03/30/%E5%9F%BA%E7%A1%80%E7%AF%87-itcast/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、二分查找1.0算法描述 前提：有已排序数组 A（假设已经做好）  定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）  获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)  中间索引的值  A[M] 与待搜索的值 T 进行比较 ① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引 ② A[M] &gt; T，中间值右侧的其它元素都大于">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/202210101009630.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202210232303927.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202210232304585.png">
<meta property="article:published_time" content="2023-03-30T09:56:52.000Z">
<meta property="article:modified_time" content="2023-03-30T13:42:20.648Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java基础-itcast">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/202210101009630.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-基础篇-itcast" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/30/%E5%9F%BA%E7%A1%80%E7%AF%87-itcast/" class="article-date">
  <time class="dt-published" datetime="2023-03-30T09:56:52.000Z" itemprop="datePublished">2023-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">视频学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      基础篇-itcast
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h1><h3 id="1-0算法描述"><a href="#1-0算法描述" class="headerlink" title="1.0算法描述"></a>1.0<strong>算法描述</strong></h3><ol>
<li><p>前提：有已排序数组 A（假设已经做好）</p>
</li>
<li><p>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</p>
</li>
<li><p>获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)</p>
</li>
<li><p>中间索引的值  A[M] 与待搜索的值 T 进行比较</p>
<p>① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引</p>
<p>② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p>
<p>③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p>
</li>
<li><p>当 L &gt; R 时，表示没有找到，应结束循环</p>
</li>
</ol>
<span id="more"></span>

<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = a.length - <span class="number">1</span>, m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &gt; t) &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-0-解决溢出问题方式一："><a href="#2-0-解决溢出问题方式一：" class="headerlink" title="2.0 解决溢出问题方式一："></a>2.0 解决溢出问题方式一：</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ClassName: binarySearchDemo</span></span><br><span class="line"><span class="comment">     * Description:解决整数溢出的二分查找 方式一 数学运算</span></span><br><span class="line"><span class="comment">     * date:2022/3/18</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> fgcy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较&quot;</span> + ++counter + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">            <span class="comment">//int middle = (left + right)/2;//如果两个很大的数相加，有可能溢出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; array[middle]) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; array[middle]) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//等跳出循环还没退出方法，说明没找到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">12</span>, <span class="number">33</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">88</span>, <span class="number">90</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        System.out.println(binarySearch1(ints, <span class="number">99</span>));</span><br><span class="line">    &#125;</span><br><span class="line">=============================================</span><br><span class="line">比较<span class="number">1</span>次</span><br><span class="line">比较<span class="number">2</span>次</span><br><span class="line">比较<span class="number">3</span>次</span><br><span class="line">比较<span class="number">4</span>次</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>



<h3 id="3-0-解决整数溢出方式二"><a href="#3-0-解决整数溢出方式二" class="headerlink" title="3.0 解决整数溢出方式二"></a>3.0 解决整数溢出方式二</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ClassName: binarySearchDemo</span></span><br><span class="line"><span class="comment">     * Description:解决整数溢出的二分查找 方式二 使用无符号右移一位【效率更高】</span></span><br><span class="line"><span class="comment">     * date:2022/3/18</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> fgcy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较&quot;</span> + ++counter + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//无符号右移一位，相当于除以二且处于最高位的必为零</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; array[middle]) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; array[middle]) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//等跳出循环还没退出方法，说明没找到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">12</span>, <span class="number">33</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">88</span>, <span class="number">90</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        System.out.println(binarySearch2(ints, <span class="number">99</span>));</span><br><span class="line">    &#125;</span><br><span class="line">==================================================</span><br><span class="line">比较<span class="number">1</span>次</span><br><span class="line">比较<span class="number">2</span>次</span><br><span class="line">比较<span class="number">3</span>次</span><br><span class="line">比较<span class="number">4</span>次</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="4-0-其它考法"><a href="#4-0-其它考法" class="headerlink" title="4.0 其它考法"></a>4.0 <strong>其它考法</strong></h3><ol>
<li><p>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 </p>
</li>
<li><p>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</p>
</li>
<li><p>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</p>
</li>
</ol>
<p>对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：</p>
<p>$$n &#x3D; log_2N &#x3D; log_{10}N&#x2F;log_{10}2$$</p>
<p>其中 n 为查找次数，N 为元素个数</p>
<h1 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h1><h3 id="0-0-算法描述"><a href="#0-0-算法描述" class="headerlink" title="0.0 算法描述"></a>0.0 <strong>算法描述</strong></h3><ol>
<li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li>
<li>重复以上步骤，直到整个数组有序</li>
</ol>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 一轮冒泡</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否发生了交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优化点1：每经过一轮冒泡，内层循环就可以减少一次</li>
<li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环</li>
</ul>
<h3 id="1-0-方式一"><a href="#1-0-方式一" class="headerlink" title="1.0 方式一"></a>1.0 方式一</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优化一冒泡排序：</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;原始数组是:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;数组长度是&quot;</span> + arr.length + <span class="string">&quot;,理论上跑&quot;</span> + (arr.length - <span class="number">1</span>) + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//数组是否可以提前停止排序</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//当本轮没有发生过交换时说明已经有序可以提前结束，但本轮有交换，所以时不能停止</span></span><br><span class="line">                    stop = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">            <span class="comment">//只要这一轮没有交换过顺序，说明可以提前停止</span></span><br><span class="line">            <span class="keyword">if</span> (stop) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序结果:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">=========================================================</span><br><span class="line">原始数组是:[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br><span class="line">数组长度是<span class="number">10</span>,理论上跑<span class="number">9</span>轮</span><br><span class="line">第<span class="number">1</span>轮：[<span class="number">3</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br><span class="line">第<span class="number">2</span>轮：[<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br><span class="line">第<span class="number">3</span>轮：[<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br><span class="line">排序结果:[<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2-0-方式二"><a href="#2-0-方式二" class="headerlink" title="2.0 方式二"></a>2.0 方式二</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优化二冒泡排序：</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;原始数组是:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;数组长度是&quot;</span> + arr.length + <span class="string">&quot;,理论上跑&quot;</span> + (arr.length - <span class="number">1</span>) + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">        <span class="comment">//第一轮需要比较全部的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//当本轮已经有序了，不需要再进行排序了，此时通过将last的值0赋给n让排序终止</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//记录每次交换后的索引</span></span><br><span class="line">                    last = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (++counter) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">            <span class="comment">//将【最后】交换的索引给n，该索引往左的都是未排序的，右边都是已经有序的</span></span><br><span class="line">            n = last;</span><br><span class="line">            <span class="comment">//n会向0靠拢，当数组提前有序时，会有last=0赋给n，让其提前终止循环</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序结果:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">===================================================</span><br><span class="line">原始数组是:[<span class="number">12</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br><span class="line">数组长度是<span class="number">10</span>,理论上跑<span class="number">9</span>轮</span><br><span class="line">第<span class="number">1</span>轮：[<span class="number">3</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br><span class="line">第<span class="number">2</span>轮：[<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br><span class="line">第<span class="number">3</span>轮：[<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br><span class="line">排序结果:[<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>] </span><br></pre></td></tr></table></figure>

<h3 id="3-0-冒泡排序总结"><a href="#3-0-冒泡排序总结" class="headerlink" title="3.0 冒泡排序总结"></a>3.0 冒泡排序总结</h3><p>文字描述冒泡排序（以升序为例）<br>    依次比较数组中相邻的两个元素的大小，若arr[i]&gt;arr[i+1]，则交换两个元素；<br>    两两都比较一遍称为一轮冒泡，结果是让最大的元素拍到最后<br>    重复上述步骤，直至整个数组有序</p>
<p>优化方式<br>    每轮冒泡时，最后一次交换的索引作为下一轮冒泡的比较次数；若这个值为零时，表示整个数组有序，直接退出外层循环即可</p>
<h1 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h1><h3 id="1-0-算法描述"><a href="#1-0-算法描述" class="headerlink" title="1.0 算法描述"></a>1.0 <strong>算法描述</strong></h3><ol>
<li><p>将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</p>
</li>
<li><p>重复以上步骤，直到整个数组有序</p>
</li>
</ol>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectedSort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">21</span>, <span class="number">1</span>, <span class="number">65</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">55</span>, <span class="number">0</span>, -<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//i代表每轮所选择出的最小元素要交换到的目标索引【要把当前轮未排序区域的最小值放到该索引上】</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//记录最小元素的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="comment">//用当前轮目前的最小值，和未排序区的元素进行比较【是s不能是i】</span></span><br><span class="line">                <span class="keyword">if</span> (array[s] &gt; array[j]) &#123;</span><br><span class="line">                    <span class="comment">//得到每轮中比较出的最小值的索引</span></span><br><span class="line">                    s = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最小索引值与每轮想要交换到的目标索引相同时，说明不需要交换</span></span><br><span class="line">            <span class="keyword">if</span> (i != s) swap(array, i, s);</span><br><span class="line">            System.out.println(<span class="string">&quot;每轮所得到的数组：&quot;</span> + Arrays.toString(array));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">=========================================================</span><br><span class="line">每轮所得到的数组：[-<span class="number">5</span>, <span class="number">1</span>, <span class="number">65</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">55</span>, <span class="number">0</span>, <span class="number">21</span>]</span><br><span class="line">每轮所得到的数组：[-<span class="number">5</span>, <span class="number">0</span>, <span class="number">65</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">55</span>, <span class="number">1</span>, <span class="number">21</span>]</span><br><span class="line">每轮所得到的数组：[-<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">55</span>, <span class="number">65</span>, <span class="number">21</span>]</span><br><span class="line">每轮所得到的数组：[-<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">55</span>, <span class="number">65</span>, <span class="number">21</span>]</span><br><span class="line">每轮所得到的数组：[-<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">55</span>, <span class="number">65</span>, <span class="number">21</span>]</span><br><span class="line">每轮所得到的数组：[-<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">65</span>, <span class="number">55</span>]</span><br><span class="line">每轮所得到的数组：[-<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">55</span>, <span class="number">65</span>]</span><br><span class="line">[-<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">55</span>, <span class="number">65</span>] </span><br></pre></td></tr></table></figure>

<ul>
<li>选择排序思路</li>
</ul>
<p>将数组分为两个子集，已排序的与未排序的，每轮从未排序的自己中选出最小的元素，放在已排序的子集中<br>重复以上步骤，直至数组有序</p>
<ul>
<li>优化方式</li>
</ul>
<p>为减少交换次数，可以先记录最先元素的索引，再在每一轮的最后进行交换</p>
<h3 id="2-0与冒泡排序比较"><a href="#2-0与冒泡排序比较" class="headerlink" title="2.0与冒泡排序比较"></a>2.0与冒泡排序比较</h3><ol>
<li><p>二者平均时间复杂度都是 $O(n^2)$</p>
</li>
<li><p>选择排序一般要快于冒泡，因为其交换次数少</p>
</li>
<li><p>但如果集合有序度高，冒泡优于选择</p>
</li>
<li><p>冒泡属于稳定排序算法，而选择属于不稳定排序</p>
<ul>
<li>稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序</li>
<li>不稳定排序则反之</li>
</ul>
</li>
</ol>
<h1 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a>四、插入排序</h1><h3 id="1-0-算法描述-1"><a href="#1-0-算法描述-1" class="headerlink" title="1.0 算法描述"></a>1.0 <strong>算法描述</strong></h3><ol>
<li><p>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</p>
</li>
<li><p>重复以上步骤，直到整个数组有序</p>
</li>
</ol>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSorted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">21</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];<span class="comment">//待插入的元素值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;<span class="comment">//已排序区域的索引</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">//已取出的值，与有序区间的值进行比较，若有序区间的值较大则后移一位,直到有序值小于拿出的值，</span></span><br><span class="line">                    <span class="comment">// 一旦发现取出的值大于有序的值则退出循环，如果一直没找到，就会空出索引为0的有序空间</span></span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//必须打破，有效率问题有算法问题（当没有移位时，不能索引减一）</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = t;<span class="comment">//将取出的值赋给空出的部分</span></span><br><span class="line">            System.out.println(<span class="string">&quot;每轮排序的数组:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">===========================================</span><br><span class="line">每轮排序的数组:[<span class="number">18</span>, <span class="number">21</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">11</span>]</span><br><span class="line">每轮排序的数组:[<span class="number">9</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">11</span>]</span><br><span class="line">每轮排序的数组:[<span class="number">9</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">11</span>]</span><br><span class="line">每轮排序的数组:[<span class="number">0</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">22</span>, -<span class="number">2</span>, <span class="number">11</span>]</span><br><span class="line">每轮排序的数组:[-<span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">11</span>]</span><br><span class="line">每轮排序的数组:[-<span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">22</span>]</span><br><span class="line">[-<span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSorted</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = t;</span><br><span class="line">            System.out.println(<span class="string">&quot;每轮排序结果：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终排序结果：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        insertSorted(arr);</span><br><span class="line">    &#125;</span><br><span class="line">每轮排序结果：[<span class="number">12</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">4</span>]</span><br><span class="line">每轮排序结果：[<span class="number">2</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">34</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">4</span>]</span><br><span class="line">每轮排序结果：[<span class="number">2</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">34</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">4</span>]</span><br><span class="line">每轮排序结果：[<span class="number">2</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">11</span>, <span class="number">4</span>]</span><br><span class="line">每轮排序结果：[<span class="number">2</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">4</span>]</span><br><span class="line">每轮排序结果：[<span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">34</span>]</span><br><span class="line">最终排序结果：[<span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">34</span>]</span><br></pre></td></tr></table></figure>





<h3 id="2-0-与选择排序比较"><a href="#2-0-与选择排序比较" class="headerlink" title="2.0 与选择排序比较"></a>2.0 <strong>与选择排序比较</strong></h3><ol>
<li><p>二者平均时间复杂度都是 $O(n^2)$</p>
</li>
<li><p>大部分情况下，插入都略优于选择</p>
</li>
<li><p>有序集合插入的时间复杂度为 $O(n)$</p>
</li>
<li><p>插入属于稳定排序算法，而选择属于不稳定排序</p>
</li>
</ol>
<p><strong>提示</strong></p>
<blockquote>
<p><em>插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序</em></p>
</blockquote>
<h3 id="3-0-总结"><a href="#3-0-总结" class="headerlink" title="3.0 总结"></a>3.0 总结</h3><p>文字描述<br>    将数组分为两个区域，已排序与未排序，每一轮从未排序中取第一个元素，插入到有序区中（需要保证顺序）<br>    重复上述步骤，直至整个数组有序</p>
<p>优化方式<br>    在与待插入元素进行比较时，若发现有序区的元素比待插入元素小，就代表找到了插入元素，无需进行后续比较<br>    插入时直接移动元素，而不是交换元素</p>
<p>与选择相比较<br>    两者的平均复杂度都是O(n)的平方<br>    大部分情况下，插入优于选择<br>    有序插入的时间复杂度为O(n)的平方，有序冒泡也是O(n)的平方<br>    插入排序属于稳定排序，选择属于不稳定</p>
<h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        XierSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">XierSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            h = h * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; h &gt; <span class="number">0</span>; h /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= h) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j - h] &gt; t) &#123;</span><br><span class="line">                        arr[j] = arr[j - h];</span><br><span class="line">                        j -= h;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;每轮间隔下：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">每轮间隔下：[<span class="number">4</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">34</span>]</span><br><span class="line">每轮间隔下：[<span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">34</span>]</span><br><span class="line">最终结果：[<span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">34</span>]</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day01.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        shell_2(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shell_</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">2</span>) &#123;</span><br><span class="line">            h = <span class="number">2</span> * h + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= h; j -= h) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j - h] &gt; arr[j]) &#123;</span><br><span class="line">                        swap(arr, j, j - h);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shell_2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">2</span>) &#123;</span><br><span class="line">            h = h * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; N; i++) &#123;</span><br><span class="line">				<span class="comment">//j &gt;= h保证最小为零，不为负数                </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= h; j -= h) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j - h] &gt; arr[j]) &#123;</span><br><span class="line">                        swap(arr, j - h, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="六、快速排序"><a href="#六、快速排序" class="headerlink" title="六、快速排序"></a>六、快速排序</h1><h3 id="1-0-算法描述-2"><a href="#1-0-算法描述-2" class="headerlink" title="1.0 算法描述"></a>1.0 <strong>算法描述</strong></h3><ol>
<li>每一轮排序选择一个基准点（pivot）进行分区<ol>
<li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li>
<li>当分区完成时，基准点元素的位置就是其最终位置</li>
</ol>
</li>
<li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li>
<li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li>
</ol>
<h3 id="2-0-单边循环快排"><a href="#2-0-单边循环快排" class="headerlink" title="2.0 单边循环快排"></a>2.0 单边循环快排</h3><ol>
<li>选择最右边的元素作为基准点</li>
<li>j指针负责找到比基准点小的元素，一旦找到就与i进行交换</li>
<li>i指针维护小于基准点元素的边界，预计是每次交换的目标索引</li>
<li>最后基准点与i交换，i即为分区位置</li>
</ol>
<ul>
<li><p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p>
<ol>
<li><p>选择最右元素作为基准点元素</p>
</li>
<li><p>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换</p>
</li>
<li><p>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</p>
</li>
<li><p>最后基准点与 i 交换，i 即为分区位置</p>
</li>
</ol>
</li>
<li><p>代码实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.find;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> t1, <span class="type">int</span> t2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[t1];</span><br><span class="line">        array[t1] = array[t2];</span><br><span class="line">        array[t2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次调用都会两边都找一下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> quickSort(arr, l, h);</span><br><span class="line">        quick(arr, l, i - <span class="number">1</span>);</span><br><span class="line">        quick(arr, i + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="comment">//基准点元素(最后一个元素)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> arr[h];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//i,j一开始都是区间最左边的元素，i负责维护小于基准点的元素的边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//j的范围是从区间最左边到基准点元素(区间最右)，找到比基准点元素小的就与i的值进行交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; h; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; pv) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                    swap(arr, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更换边界值索引，往右移是因为当前索引所知的值已经与j的值进行交换比基准点小</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != h) &#123;<span class="comment">//当边界值与基准元素是同一个时，不交换</span></span><br><span class="line">            swap(arr, i, h);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        quick(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==================================</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>



<h3 id="3-0-双边快排"><a href="#3-0-双边快排" class="headerlink" title="3.0 双边快排"></a>3.0 双边快排</h3><p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p>
<ol>
<li>选择最左元素作为基准点元素</li>
<li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li>
<li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li>
</ol>
<p>要点</p>
<ol>
<li><p>基准点在左边，并且要先 j 后 i</p>
</li>
<li><p>while( <strong>i</strong> **&lt; j** &amp;&amp; a[j] &gt; pv ) j– </p>
</li>
<li><p>while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] <strong>&lt;&#x3D;</strong> pv ) i++</p>
</li>
<li><p>选择最左边元素作为基准点元素</p>
</li>
<li><p>j指针负责从右向左找比基准点小的元素，i指针负责从右往左找比基准点大的元素，一旦找到两者交换，直至i，j相交</p>
</li>
<li><p>最后基准点与i（此时i与j相等）交换，i极为分区位置</p>
</li>
</ol>
<ul>
<li>几个要点</li>
</ul>
<ol>
<li>基准点在左边，并且要先j后i</li>
<li>while(i&lt;j &amp;&amp; a[j]&gt;pv) j–;</li>
<li>while(i&lt;j &amp;&amp; a[i]&gt;&#x3D;pv) i++;</li>
</ol>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> t1, <span class="type">int</span> t2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[t1];</span><br><span class="line">        array[t1] = array[t2];</span><br><span class="line">        array[t2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次调用都会两边都找一下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="comment">//当区间中只有一个元素时</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> quickSort(arr, l, h);</span><br><span class="line">        <span class="comment">//对左边分区进行排序</span></span><br><span class="line">        quick(arr, l, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//对右边分区进行排序</span></span><br><span class="line">        quick(arr, i + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="comment">//取区间最左边的值作为基准值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> arr[l];</span><br><span class="line">        <span class="comment">//i为区间左边第一个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="comment">//j为区间右边第一个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *先从j开始找，找到比基准值小的就记录下索引值；否则j--</span></span><br><span class="line"><span class="comment">         * 再从i开始找，找到比基准值大的就记录下索引；否则i++</span></span><br><span class="line"><span class="comment">         * 交换i，j两个索引处的值当他们相遇时，就退出循环</span></span><br><span class="line"><span class="comment">         * 交换基准值和i所对应的值</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pv) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pv) i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, j, l);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        quick(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">======================================================</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>快速排序特点</li>
</ul>
<ol>
<li>平均时间复杂度：O(n log2 n次方)，最坏时间复杂度：O(n 2平方)</li>
<li>数据量大时，优势特别明显</li>
<li>属于不稳定排序（选择排序）</li>
</ol>
<p><strong>快排特点</strong></p>
<ol>
<li><p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$</p>
</li>
<li><p>数据量较大时，优势非常明显</p>
</li>
<li><p>属于不稳定排序</p>
</li>
</ol>
<h1 id="七、集合"><a href="#七、集合" class="headerlink" title="七、集合"></a>七、集合</h1><h2 id="1-0-ArrayList的扩容机制"><a href="#1-0-ArrayList的扩容机制" class="headerlink" title="1.0 ArrayList的扩容机制"></a>1.0 ArrayList的扩容机制</h2><ul>
<li>​	<strong>扩容规则</strong></li>
</ul>
<ol>
<li><p>ArrayList() 会使用长度为零的数组</p>
</li>
<li><p>ArrayList(int initialCapacity) 会使用指定容量的数组，扩容机制&gt;&gt;&gt;1.5</p>
</li>
<li><p>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</p>
</li>
<li><p>add(Object o) 首次扩容为 <code>10</code>，再次扩容为上次容量的 1.5 倍</p>
</li>
<li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p>
</li>
</ol>
<blockquote>
<p> 其中第 4 点必须知道，其它几点视个人情况而定</p>
</blockquote>
<ul>
<li><p>ArrayList的初始容量</p>
<p>使用无参构造的方法:容量是零(长度为零的对象数组)<br>使用一个int类型作为入参的构造方法:容量是入参(长度为入参长的对象数组)<br>使用一个集合类型作为入参的构造方法：容量是集合的大小</p>
</li>
<li><p>add()扩容</p>
<p>当使用ArrayList的无参构造创建对象时，会给分配一个长度为零的数组，当加入第一个元素时，会创建一个长度为10的数组(扩容)，这个数组会替换掉原来的空数组； </p>
<p>当加入第十一个元素时【要插入的元素下标等于数组大小】，ArrayList又进行扩容，为原来的1.5倍(创建一个长度为15的数组，将原来数组的元素拷贝到新数组中)，原来的数组因为没有引用指向，会被gc干掉；</p>
<p>当加入第16个元素时，ArrayList又进行扩容，将15&gt;&gt;&gt;1 &#x3D;7,15+7&#x3D;22;创建一个长度为22的数组，将原来数组的元素拷贝到新数组中，原来的数组因为没有引用指向，会被gc干掉；</p>
</li>
<li><p>addAll()扩容</p>
</li>
</ul>
<ol>
<li>现在集合中元素个数为零，下一次会扩容为10，添加一个元素个数小于等于10的集合，此时该集合扩容为10；</li>
<li>现在集合中元素个数为零，下一次会扩容为10，添加一个元素个数为22的集合，此时该集合扩容为22；Math.max(10,22)</li>
<li>现在集合中元素个数为11个，下一次会扩容为22 ，添加一个元素个数为10的集合（此时所有元素个数为21&lt;22），此时该集合扩容为22；Math.max(21,22)</li>
</ol>
<ul>
<li>扩容机制</li>
</ul>
<ol>
<li>ArrayList() 无参构造会使用长度为零的数组</li>
<li>ArrayList(int initialCapacity)会使用指定容量的数组，但是扩容是懒惰式的的，即在没有添加元素前，即使制定了长度，也不会创建数组</li>
<li>public ArrayList(Collection&lt;? extends E&gt; c)会使用c的大小作为数组容量</li>
<li>add(Object o)首次扩容为十，再次扩容为原来的1.5倍（先右移一位，再加上原来数组的长度）</li>
<li>addAll(Conllection c)没有元素时，扩容为Math.max(10,实际元素个数)，有元素时为Math.max(原容量的1.5倍，实际元素个数)</li>
</ol>
<p><strong>首先，通过无参构造创建一个ArrayList对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure>



<p>底层原理：调用无参构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的值为“&#123;&#125;”，为空数组</span></span><br></pre></td></tr></table></figure>

<p>即使用ArrayList创建ArrayList对象时，并没有初始化底层数组elementData，等到调用add(E e) 方法的时候再初始化elementData，这种”懒加载”模式可以节省内存。</p>
<p><strong>调用add(E e) 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayList.add(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>底层原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">// 确认elementData容量是否足够</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 第一次调用add()方法时，size=0</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p>先调用<code>ensureCapacityInternal</code>(int minCapacity) 方法,对数组容量进行检查，不够时则进行扩容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当当前集合的数组为“&#123;&#125;”时，初始化容量，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    	<span class="comment">//即第一次调用add(E e)， 如果elementData为&quot;&#123;&#125;&quot;,重新定义minCapacity的值，赋值为DEFAULT_CAPACITY=10</span></span><br><span class="line">    	<span class="comment">// 即第一次调用add(E e)方法时，定义底层数组elementData的长度为10</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 判断是否需要扩容</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>ensureExplicitCapacity(minCapacity) 判断是否需要扩容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 第一次进入时，minCapacity=10,elementData.length=0,对数组进行扩容</span></span><br><span class="line">        <span class="comment">// 之后再进入时，minCapacity=size+1，elementData.length=10(每次扩容后会改变)，</span></span><br><span class="line">        <span class="comment">// 需要minCapacity&gt;elementData.length成立，才能扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>grow(minCapacity) 对数组进行扩容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数组长度赋值给oldCapacity</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 将oldCapacity右移一位再加上oldCapacity，即相当于newCapacity=1.5oldCapacity(不考虑精度损失)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 如果newCapacity还是小于minCapacity，直接将minCapacity赋值给newCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特殊情况：newCapacity的值过大，直接将整型最大值赋给newCapacity，</span></span><br><span class="line">	<span class="comment">// 即newCapacity=Integer.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// 将elementData的数据拷贝到扩容后的数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果大于临界值，进行整型最大值的分配</span></span><br><span class="line"><span class="comment">//private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<p>使用ArrayList()创建ArrayList对象时，不会定义底层数组的长度，当第一次调用add(E e) 方法时，初始化定义底层数组的长度为10，之后调用add(E e)时，如果需要扩容，则调用grow(int minCapacity) 进行扩容,长度为原来的1.5倍。</p>
<p>ArrayList还有有参构造器：ArrayList(int initialCapacity) 和 ArrayList(Collection&lt;? extends E&gt; c)，前则创建可以指定初始容量的集合，后者创建一个包含指定collection元素的集合，两者的底层数组初始化和扩容机制与上述ArrayList()一样，且添加方法add(int index, E e)和add(E e)的扩容机制一样。</p>
<h2 id="2-0-Iterator的fail-fast、fail-safe"><a href="#2-0-Iterator的fail-fast、fail-safe" class="headerlink" title="2.0 Iterator的fail-fast、fail-safe"></a>2.0 Iterator的fail-fast、fail-safe</h2><p>Fail-Fast 与 Fail-Safe</p>
<ul>
<li><p><code>ArrayList </code>    <code>Vector</code>是 fail-fast 的典型代表，<strong>遍历的同时不能修改</strong>，尽快失败</p>
</li>
<li><p><code>CopyOnWriteArrayList </code>是 fail-safe 的典型代表，<strong>遍历的同时可以修改</strong>，原理是读写分离</p>
</li>
</ul>
<p><strong>fail-fast</strong></p>
<p>ArrayList时fail-fast的典型代表，遍历的同时不能修改，否则抛错，尽快失败<br>一旦发现遍历的时候别人来修改，立即抛异常</p>
<p>并发修改异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;D&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用增强for循环时，底层调用的是iterator迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">        list.remove(student);  <span class="comment">//java.util.ConcurrentModificationException</span></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合中 通过方法返回一个迭代器对象给增强for</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();<span class="comment">//会调用成员内部类的无参构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//成员内部类</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">     </span><br><span class="line">     	<span class="comment">//modCount是ArrayList的实例成员变量，记录当前ArrayList实例被修改的次数</span></span><br><span class="line">     	<span class="comment">//expectedModCount是迭代器实例维护的实例成员变量，记录一开始获得数组时，数组被修改的次数；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//下一个元素的下标不等于该集合的大小</span></span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//-----------------------------------------------------------------</span></span><br><span class="line">     <span class="comment">//每次取出元素时都会查看集合是否被修改了，若改了就抛异常</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>fail-save</strong></p>
<p>发现遍历的时候有人来修改，会采取一些策略，例如：<strong>牺牲一致性</strong>来让整个遍历完成<br><code>CopyOnWriteArrayList</code>是<code> fail-safe</code> 的典型代表，遍历的同时可以修改，<strong>原理是读写分离</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    final CopyOnWriteArrayList&lt;Student&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    list.add(new Student(&quot;A&quot;));</span><br><span class="line">    list.add(new Student(&quot;B&quot;));</span><br><span class="line">    list.add(new Student(&quot;C&quot;));</span><br><span class="line">    list.add(new Student(&quot;D&quot;));</span><br><span class="line"></span><br><span class="line">    //增强for底层调用迭代器</span><br><span class="line">    for (Student student : list) &#123;</span><br><span class="line">        list.remove(student);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name:&#x27;A&#x27;&#125;</span><br><span class="line">Student&#123;name:&#x27;B&#x27;&#125;</span><br><span class="line">Student&#123;name:&#x27;C&#x27;&#125;</span><br><span class="line">Student&#123;name:&#x27;D&#x27;&#125;</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前实例的数组，用于在迭代器中也维护一份（集合中每次添加新的元素就会创建一个长度+1的数组，将原数组的值复制到新数组中，	并将新数组作为底层数组），这样修改集合中的元素，对迭代器没有影响</span></span><br><span class="line">   <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>对集合进行修改时，先复制出一份，再进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Object[] elements = getArray();</span><br><span class="line">          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">          Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">          newElements[len] = e;</span><br><span class="line">          setArray(newElements);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CopyOnWriteArrayList的读写分离，弱一致性</p>
</blockquote>
<h2 id="3-0-LinkedList和ArrayList"><a href="#3-0-LinkedList和ArrayList" class="headerlink" title="3.0 LinkedList和ArrayList"></a>3.0 LinkedList和ArrayList</h2><p><strong>LinkedList</strong></p>
<ol>
<li>基于双向链表，无需连续内存</li>
<li>随机访问慢（要沿着链表遍历）</li>
<li><strong>头尾插入 删除</strong>性能高</li>
<li>占用内存多</li>
</ol>
<p><strong>ArrayList</strong></p>
<ol>
<li>基于数组，需要连续内存</li>
<li>随机访问快（指根据下标访问）</li>
<li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li>
<li>可以利用 cpu 缓存 –&gt; 局部性原理</li>
</ol>
<p>两者比较：<br>    ArrayList</p>
<ol>
<li><p>基于数组，需要连续内存</p>
</li>
<li><p>随机访问快【根据下标访问】（根据数组地址，元素类型，索引综合计算）直接得到想要访问元素的地址</p>
</li>
<li><p>尾部插入、删除性能尚可；其他地方插入、删除需要移动元素，性能较低(尤其是头部)【<strong>综合性能ArrayList要优于LinkedList</strong>】</p>
</li>
<li><p>可以利用cpu缓存(cpu与内存之间访问所需的时间较长，所以使用cpu缓存，来提升读写性能)，局部性原理(访问一个数据的时候，</p>
<p>cpu会默认认为它附近的元素有很大概率会被访问，所以一并加载进cpu缓存)</p>
</li>
</ol>
<p>LinkedList</p>
<ol>
<li>基于双向链表，无需连续内存</li>
<li>随机访问慢（需要沿着链表遍历）</li>
<li>头尾插入性能较高，容易查到【查询中间元素，性能略低于ArrayList】</li>
<li>内存占用多（除了要存储对象地址外，还需要存储头节点地址，尾节点地址，头部节点和尾部节点）</li>
</ol>
<h1 id="八、HashMap"><a href="#八、HashMap" class="headerlink" title="八、HashMap"></a>八、HashMap</h1><h2 id="1-0-基本数据结构"><a href="#1-0-基本数据结构" class="headerlink" title="1.0 基本数据结构"></a>1.0 基本数据结构</h2><ul>
<li>1.7 数组 + 链表</li>
<li>1.8 数组 + （链表 | 红黑树）</li>
</ul>
<h2 id="2-0-树化与退化"><a href="#2-0-树化与退化" class="headerlink" title="2.0 树化与退化"></a>2.0 树化与退化</h2><p><strong>树化意义</strong></p>
<ul>
<li>红黑树用来避免 <code>DoS </code> 攻击，防止链表超长时性能下降，树化应当是 偶然情况，是保底策略</li>
<li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 O(log⁡2N )，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li>
<li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 <code>0.75 </code>的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li>
</ul>
<p><strong>树化规则</strong></p>
<ul>
<li>当 <strong>链表长度</strong> 超过  <strong>树化阈值 8</strong> 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li>
</ul>
<p><strong>退化规则</strong></p>
<ul>
<li>情况1：在扩容时如果  <strong>拆分树</strong> 时，<strong>树元素个数 &lt;&#x3D; 6</strong> 则会退化链表</li>
<li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li>
</ul>
<h2 id="3-0-索引计算"><a href="#3-0-索引计算" class="headerlink" title="3.0 索引计算"></a>3.0 索引计算</h2><p><strong>索引计算方法</strong></p>
<ul>
<li>首先，计算对象的 hashCode()</li>
<li>再进行调用 HashMap 的 hash() 方法进行二次哈希<ul>
<li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li>
</ul>
</li>
<li>最后 二次hash值 &amp; (capacity – 1) 得到索引 <strong>hash%tab.length</strong>等价于<strong>hash&amp;(tab.lenngth-1)</strong></li>
</ul>
<p><strong>数组容量为何是 2 的 n 次幂</strong></p>
<ol>
<li>计算索引时效率更高：如果是 2 的 n 次幂可以使用 <strong>位与运算</strong> 代替取模</li>
<li>扩容时重新计算索引效率更高： <strong>hash &amp; oldCap</strong> &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>二次 hash 是为了配合 <strong>容量是 2 的n次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li>
<li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 <code>Hashtable</code></li>
</ul>
<h2 id="4-0-put-与扩容"><a href="#4-0-put-与扩容" class="headerlink" title="4.0 put 与扩容"></a>4.0 put 与扩容</h2><p><strong>put 流程</strong></p>
<ol>
<li>HashMap 是懒惰创建数组的，首次使用才创建数组</li>
<li>计算索引（桶下标）</li>
<li>如果桶下标还没人占用，创建 Node 占位返回</li>
<li>如果桶下标已经有人占用<ol>
<li>已经是 TreeNode 走红黑树的添加或更新逻辑</li>
<li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li>
</ol>
</li>
<li>返回前检查容量是否超过阈值，一旦超过进行扩容</li>
</ol>
<p><strong>1.7 与 1.8 的区别</strong></p>
<ol>
<li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p>
</li>
<li><p>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</p>
</li>
<li><p>1.8 在扩容计算 Node 索引时，会优化</p>
</li>
</ol>
<p><strong>扩容（加载）因子为何默认是 0.75f</strong></p>
<ol start="2">
<li>大于这个值，空间节省了，但链表就会比较长影响性能</li>
<li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li>
</ol>
<blockquote>
<p> 在空间占用与查询时间之间取得较好的权衡</p>
</blockquote>
<h2 id="5-0-并发问题"><a href="#5-0-并发问题" class="headerlink" title="5.0 并发问题"></a>5.0 并发问题</h2><p><strong>扩容死链（1.7 会存在）</strong></p>
<p>1.7 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数据错乱（1.7，1.8 都会存在）</strong></li>
</ul>
<p>​		多线程下put()元素导致元素缺失</p>
<h2 id="6-0-key-的设计"><a href="#6-0-key-的设计" class="headerlink" title="6.0 key 的设计"></a>6.0 key 的设计</h2><ul>
<li><strong>key 的设计要求</strong></li>
</ul>
<ol>
<li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li>
<li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li>
<li>key 的 hashCode 应该有良好的散列性</li>
</ol>
<ul>
<li><p><strong>String 对象的 hashCode() 设计</strong></p>
<ul>
<li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li>
<li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 </li>
<li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li>
<li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 <ul>
<li>即 $32 ∗h -h $</li>
<li>即 $2^5  ∗h -h$</li>
<li>即 $h≪5  -h$</li>
</ul>
</li>
<li>想要散列效果较好就选择，是奇数的素数</li>
</ul>
</li>
<li><p>底层结构，1.7与1.8有什么不同</p>
</li>
</ul>
<p>1.7: </p>
<pre><code>  1. 数组 + 链表
  2. 链表插入节点时使用头插法
  3. 当前元素个数大于等于阈值(当前数组长度的四分之三)且要插入的元素的桶下标对应的位置有元素时，才进行扩容；
  4. 扩容后，要迁移元素；计算Node桶下标时没有优化（二次hash值 &amp; oldCapacity == 0则不用移动；否则移动到新的桶下标位置去 新位置=当前桶下标+oldCacity）
</code></pre>
<p>1.8: </p>
<pre><code> 1.  数组 + 链表(或红黑树)
 2.  链表插入节点时使用尾插法
 3.  当前元素个数大于等于阈值【当前数组长度的四分之三】时，扩容；
 4.  扩容后，要迁移元素；计算Node桶下标时有优化（二次hash值 &amp; oldCapacity == 0则不用移动；否则移动到新的桶下标位置去 新位置=当前桶下+oldCacity）
</code></pre>
<ul>
<li><p><strong>modecount的作用</strong></p>
<p>HashMap时线程不安全的<br>每修改一次hashMap对象，modcount就会+1；</p>
<p>当使用迭代器遍历时，它会记录下当前的modcount数量【expextedModcount】，每次取下一个元素时就会，就会判断expectModcount与modcount是否相等，不相等，就并发修改异常</p>
</li>
<li><p>1.7</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 算桶下标</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    	<span class="comment">//HashMap的Entry数组长度必须是  non-zero power of 2</span></span><br><span class="line">    	<span class="comment">//hashCode和数组长度减一按位与；数组长度减一是桶下标范围；</span></span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span> 使用无参构造实例HashMap</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//默认初始化长度1&lt;&lt;4,加载因子0.75</span></span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> put方法</span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    	<span class="comment">//判读数组是不是之前的空数组</span></span><br><span class="line">    	<span class="comment">//static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;数组一开始是长度为0的数组</span></span><br><span class="line">    	<span class="comment">// transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            <span class="comment">//数组是长度为0的数组，就创建一个长度不为零的数组</span></span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    	<span class="comment">//二次hash</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    	<span class="comment">//算桶下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">     	<span class="comment">//遍历链表，添加元素时，如果发现链表中的键与新加的键相同时，旧值返回，新值替换旧值</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//修改次数</span></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 头插法</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    	<span class="comment">//创建一个新的Entry对象，它的next是当前桶下标的数组中的引用，接着将将自己的引用赋给当前桶下标的数组</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    	<span class="comment">//当前总元素个数+1</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span> 初始化数组大小 【当put元素时，才会创建有大小的数组】</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    	<span class="comment">//找到一个大于等于2的n次方数的数</span></span><br><span class="line">    	<span class="comment">//toSize是调用构造时传入的初始化参数，无参时默认16</span></span><br><span class="line">    	<span class="comment">//数组长度一定时 2的幂次方数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);</span><br><span class="line">		<span class="comment">//扩容阈值</span></span><br><span class="line">        threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span> hashMap扩容</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    	<span class="comment">//threshold通过加载因子和数组长度计算出的扩容阈值</span></span><br><span class="line">    	<span class="comment">//如果插入的桶下标中为null，即使现在已经满了阈值也不扩容【1.7】</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//扩容为原来的两倍</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 扩容</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//两倍长度数组</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    	<span class="comment">//元素转移</span></span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> 元素转移</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    新数组下标有两种情况： 原来的桶下标；原来的桶下标+原来数组长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    	<span class="comment">//遍历Entry数组</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//得到新的桶下标，原来的hashCode新的数组长度</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                <span class="comment">//【1.7】头插法，新数组桶下标中的引用作为要转移元素的下一个元素</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                <span class="comment">//要转移的元素作为桶下标中的引用</span></span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                <span class="comment">//在链表中下移</span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">9.</span> 判断是否要rehash</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">initHashSeedAsNeeded</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    	<span class="comment">//hashSeed默认为零</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">currentAltHashing</span> <span class="operator">=</span> hashSeed != <span class="number">0</span>;<span class="comment">//false</span></span><br><span class="line">    	<span class="comment">//jvm是否启动</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">useAltHashing</span> <span class="operator">=</span> sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            	<span class="comment">//当前数组容量是否大于某个值 默认整形最大 可以通过配置jvm参数改变</span></span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    	<span class="comment">//异或 不同为真 useAltHashing一定为真</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">switching</span> <span class="operator">=</span> currentAltHashing ^ useAltHashing;</span><br><span class="line">        <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">            hashSeed = useAltHashing</span><br><span class="line">                ? sun.misc.Hashing.randomHashSeed(<span class="built_in">this</span>)</span><br><span class="line">                : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> switching;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">11.</span> 多线程扩容时形成死链</span><br></pre></td></tr></table></figure>



<ul>
<li>为什么要用红黑树</li>
</ul>
<p>当链表过长时，访问的效率会变低；而红黑树增删查改性能较高，当链表长度过长时，对查询性能的影星不大</p>
<ul>
<li>为什么不直接红黑树</li>
</ul>
<p>一般情况下，元素在哈希表中存储呈现泊松分布，很少有较长的链表；<br>在链表较短的情况下，查询的性能要优于红黑树；只有在链表很长的情况下，性能才远远不如红黑树<br>红黑树较于链表来说需要花费更大的存储空间；TressNode占用的空间比Node要大，所以，如非必要，尽量不要使用红黑树<br>树化是一种特殊情况，使用红黑树是为了避免被DOS攻击后导致链表过长使得查询性能降低；</p>
<ul>
<li>红黑树的阈为什么是8</li>
</ul>
<p>当hash值足够随机时，元素在hash表内呈现泊松分布，在负载因子0.75的情况下，长度超过8的链表出现的概率为0.00000006<br>选择8是为了让树化的概率足够小</p>
<ul>
<li>什么时候会转成红黑树</li>
</ul>
<p>当链表的长度大于8时，会先判断当前数组长度，如果数组长度小于64，则进行扩容；<br>当链表的长度大于8时，且数组长度大于等于64，此时会将链表转化为红黑树</p>
<ul>
<li>什么时候会退化成链表</li>
</ul>
<p>​	两种情况：</p>
<pre><code>1. 在扩容时，如果发生拆分树的情况，当树元素个数小于等于6时，就会退化成链表
   【当当前的数组所有元素个数大于当前数组长度的四分之三时，数组会扩容为原来的两倍】当移除树的节点时，若root、root.left、root.right、root.left.left有一个为null时，会退化成链表
</code></pre>
<ul>
<li>索引值如何计算</li>
</ul>
<ol>
<li>首先调用对象的hashCode方法得到原始hash，再通过HashMap的hash方法对原始hash进行计算得到二次hash;</li>
<li>最后通过二次hash的值对当前数组长度取模获取索引值（桶下标）【这种是方便人计算，当数组容量是2的n次幂时，走的是下面 按位与的方式，效率更高】</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">97 % 16 =1  97&amp;(16-1)=1</span><br></pre></td></tr></table></figure>



<p>二次hash值 &amp; （capacity-1）；注意：capacity的值必须是二的几次幂的形式</p>
<ul>
<li>HashMap中的hash</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当hashCode非空时，将原来的hashcode右移十六位取高位十六位，再与原来的hashCode作异或运算    </span></span><br><span class="line"><span class="comment">//二次hash的好处，使得元素在数组中的分布尽可能随机</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二次hash的目的</li>
</ul>
<p>​		二次hash是为了综合高位数据，使得元素分布更加均匀</p>
<ul>
<li>数组容量为何是2的n次幂</li>
</ul>
<ol>
<li><p>计算索引时，如果使用的是2的n次幂的形式，那么取模运算可以用按位与来替代，效率更高；</p>
</li>
<li><p>扩容时，如果 (hash &amp; oldCapacity) &#x3D;&#x3D;  ，否则到新的位置（新位置&#x3D;旧位置+oldCapacity）</p>
</li>
<li><p>如果数组采用的是2的n次幂作为容量时，说明更加看重性能（与上面的1 2配合使用);如果采用质数作为数组容量，则hash分布更加均匀；不能说那种设计更优，这是设计者综	合各种因素最终选择使用2的n次幂作为数组容量</p>
</li>
</ol>
<ul>
<li>put方法流程，1.7、1.8有何不同</li>
</ul>
<ol>
<li>HashMap是懒惰创建数组，首次使用put添加元素时才创建数组；</li>
<li>计算索引（桶下标）【通过key的值得到hashCode，再通过HashMap的hash方法对hashCode进行计算得到二次hash的值，将 二次hash值 &amp; (capacity-1)】</li>
<li>如果桶下标没人占用，创建Node节点占用</li>
<li>如果桶下标已经有人占用，分两种情况：<br>一：已经是TreeNode，走红黑树的添加或更新逻辑(equals比较相同)<br>二：是普通Node节点，走链表的更新(equals比较相同)或添加逻辑，当链表过长时就进行树化(链表长度是否大于8 &amp;&amp; 数组长度是否大于等于16)</li>
<li>添加元素后判断当前总元素个数是否大于当前数组长度的四分之三，一旦超过就扩容</li>
</ol>
<ul>
<li>加载因子为何默认是0.75f</li>
</ul>
<ol>
<li>在空间占用与查询时间之间取得了较好的平衡</li>
<li>大于这个值，空间节省了，但不能即时扩容会导致链表可能过长，影响查询性能；</li>
<li>小于这个值，冲突减少了(链表长度可能会减少)，但空间频繁扩容，空间占用多</li>
</ol>
<ul>
<li>Key是否能为null，作为key的对象有什么要求？</li>
</ul>
<ol>
<li>HashMap的key可以为null，但Map的其他实现类则不然 concurrentHashMap、HashTable、TreeMap；</li>
<li>作为key的对象必须实现hashCode和equals</li>
<li>key的内容不可以修改</li>
</ol>
<ul>
<li>String对象的hashCode如何设计？为什么每次乘以31？</li>
</ul>
<p>任何对象的hashCode都应该足够独特，目标为达到较为均匀的散列效果<br> hashCode设计：</p>
<pre><code>1. 字符串中的每个字符都可以表现为一个数字，称为Si，i的范围是 0到n-1，n是元素个数
2. 代入散列公式： 

S0*31^ n-1+S1*31^ n-2+s3*31^N-3+...&quot;123456&quot; 49*31^5 + 50*31^4 + 51*31^3 + 52*31^2 + 53*31^1 + 54*31^0

3. `  31`  代入公式有较好的散列特性，并且算数可以优化 31x = (32-1)x = 32x-x = 2^5x-x = x&lt;&lt;5-x
</code></pre>
<ul>
<li><p>多线程下操作HahMap</p>
</li>
<li><ul>
<li>问题一（数据错乱）：并发丢失数据</li>
</ul>
</li>
<li><ul>
<li>问题二：死链</li>
</ul>
</li>
</ul>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/202210101009630.png"></p>
<hr>
<h1 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h1><h2 id="1-0-饿汉懒汉区别"><a href="#1-0-饿汉懒汉区别" class="headerlink" title="1.0 饿汉懒汉区别"></a>1.0 饿汉懒汉区别</h2><p>饿汉本质是在静态代码块中调用私有构造；所以一碰到类就会初始化</p>
<p>懒汉本质就是不在静态代码块中，调用私有构造</p>
<h2 id="2-0-饿汉单例"><a href="#2-0-饿汉单例" class="headerlink" title="2.0 饿汉单例"></a>2.0 饿汉单例</h2><h3 id="2-1-饿汉单例-反射破坏单例-预防"><a href="#2-1-饿汉单例-反射破坏单例-预防" class="headerlink" title="2.1 饿汉单例 (反射破坏单例+预防)"></a>2.1 饿汉单例 (反射破坏单例+预防)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.design_pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: SingletonDemo1</span></span><br><span class="line"><span class="comment"> * Description:饿汉式单例</span></span><br><span class="line"><span class="comment"> * date:2022/3/19</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fgcy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonDemo1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预防反射破坏单例</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;the instance is already exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethods()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用类的静态方法，使得SingletonDemo1这个类 加载、连接、初始化</span></span><br><span class="line">        <span class="comment">//也就是静态常量SingletonDemo1对象被创建</span></span><br><span class="line">        SingletonDemo1.otherMethod();</span><br><span class="line">        System.out.println(SingletonDemo1.getInstance());</span><br><span class="line">        System.out.println(SingletonDemo1.getInstance());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 反射破坏单例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reflection(SingletonDemo1.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reflection</span><span class="params">(Class&lt;SingletonDemo1&gt; clazz)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;SingletonDemo1&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//暴力反射</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;通过反射获取的实例&quot;</span> + constructor.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==================反射破坏单例===============</span><br><span class="line">无参构造</span><br><span class="line">otherMethods()</span><br><span class="line">com.itheima.design_pattern.SingletonDemo1@330bedb4</span><br><span class="line">com.itheima.design_pattern.SingletonDemo1@330bedb4</span><br><span class="line">无参构造<span class="comment">//反射调用构造器获取对象</span></span><br><span class="line">通过反射获取的实例com.itheima.design_pattern.SingletonDemo1@2503dbd3</span><br><span class="line">=====================预防反射破坏单例==================</span><br><span class="line">无参构造</span><br><span class="line">otherMethods()</span><br><span class="line">com.itheima.design_pattern.SingletonDemo1@330bedb4</span><br><span class="line">com.itheima.design_pattern.SingletonDemo1@330bedb4</span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">Caused by: java.lang.RuntimeException: the instance is already exist</span><br></pre></td></tr></table></figure>





<h3 id="2-2-饿汉单例-反序列化破坏单例-预防"><a href="#2-2-饿汉单例-反序列化破坏单例-预防" class="headerlink" title="2.2 饿汉单例 (反序列化破坏单例+预防)"></a>2.2 饿汉单例 (反序列化破坏单例+预防)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.design_pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: SingletonDemo1</span></span><br><span class="line"><span class="comment"> * Description:饿汉式单例</span></span><br><span class="line"><span class="comment"> * date:2022/3/19</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fgcy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//当希望该类的对象可以转为字节保存在磁盘中或进行网络传输时，实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo2</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonDemo2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预防反射破坏单例</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;the instance is already exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethods()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预防反序列化破化单例</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用类的静态方法，使得SingletonDemo1这个类 加载、连接、初始化</span></span><br><span class="line">        <span class="comment">//也就是静态常量SingletonDemo1对象被创建</span></span><br><span class="line">        SingletonDemo1.otherMethod();</span><br><span class="line">        System.out.println(SingletonDemo2.getInstance());</span><br><span class="line">        System.out.println(SingletonDemo2.getInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.反序列化破坏单例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serializable(SingletonDemo2.getInstance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.反序列化破坏单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializable</span><span class="params">(SingletonDemo2 instance)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        <span class="comment">//字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray()));</span><br><span class="line">        <span class="comment">//反序列化创建对象，不走构造器，直接从文件中生成</span></span><br><span class="line">        System.out.println(ois.readObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">====================反序列化破坏单例======================</span><br><span class="line">无参构造</span><br><span class="line">otherMethods()</span><br><span class="line">无参构造</span><br><span class="line">com.itheima.design_pattern.SingletonDemo2@330bedb4</span><br><span class="line">com.itheima.design_pattern.SingletonDemo2@330bedb4</span><br><span class="line">com.itheima.design_pattern.SingletonDemo2@7b23ec81<span class="comment">//不通过构造器获得新对象</span></span><br><span class="line">====================预防反序列化破坏单例======================</span><br><span class="line">无参构造</span><br><span class="line">otherMethods()</span><br><span class="line">无参构造</span><br><span class="line">com.itheima.design_pattern.SingletonDemo2@330bedb4</span><br><span class="line">com.itheima.design_pattern.SingletonDemo2@330bedb4</span><br><span class="line">com.itheima.design_pattern.SingletonDemo2@330bedb4    </span><br></pre></td></tr></table></figure>





<h3 id="2-3-unSave破坏单例"><a href="#2-3-unSave破坏单例" class="headerlink" title="2.3 unSave破坏单例"></a>2.3 unSave破坏单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.design_pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: SingletonDemo1</span></span><br><span class="line"><span class="comment"> * Description:饿汉式单例</span></span><br><span class="line"><span class="comment"> * date:2022/3/19</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fgcy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonDemo3</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethods()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用类的静态方法，使得SingletonDemo1这个类 加载、连接、初始化</span></span><br><span class="line">        <span class="comment">//也就是静态常量SingletonDemo1对象被创建</span></span><br><span class="line">        SingletonDemo1.otherMethod();</span><br><span class="line">        System.out.println(SingletonDemo3.getInstance());</span><br><span class="line">        System.out.println(SingletonDemo3.getInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//unsave破坏单例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> getUnsafe().allocateInstance(SingletonDemo3.class);</span><br><span class="line">            System.out.println(instance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ClassName: TestSingleton</span></span><br><span class="line"><span class="comment">     * Description:通过反射获取Unsave实例</span></span><br><span class="line"><span class="comment">     * date:2022/3/19</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> fgcy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            <span class="comment">//因为 Unsafe 的 theUnsafe 字段是private 的，所以这里需要设置成可访问的</span></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//Unsafe 的这个属性 theUnsafe 是静态的所以这里的get参数就是null</span></span><br><span class="line">            <span class="comment">//因为get(Object obj))是获取某个实例的属性，类属性属于类不属于实例，实例只是共享</span></span><br><span class="line">            <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===============Unsave破坏单例（无解）========================</span><br><span class="line">无参构造</span><br><span class="line">otherMethods()</span><br><span class="line">无参构造</span><br><span class="line">com.itheima.design_pattern.SingletonDemo3@330bedb4</span><br><span class="line">com.itheima.design_pattern.SingletonDemo3@330bedb4</span><br><span class="line">com.itheima.design_pattern.SingletonDemo3@4b67cf4d</span><br></pre></td></tr></table></figure>







<h2 id="3-0-枚举饿汉式"><a href="#3-0-枚举饿汉式" class="headerlink" title="3.0 枚举饿汉式"></a>3.0 枚举饿汉式</h2><h3 id="3-1-认识枚举类"><a href="#3-1-认识枚举类" class="headerlink" title="3.1 认识枚举类"></a>3.1 认识枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.design_pattern;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line">    MALE, FEMALE;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sex</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Sex&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sex</span><span class="params">(String name, <span class="type">int</span> ordinal)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        MALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        FEMALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-2枚举类实现饿汉式单例"><a href="#3-2枚举类实现饿汉式单例" class="headerlink" title="3.2枚举类实现饿汉式单例"></a>3.2枚举类实现饿汉式单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.design_pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举实现饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingletonTest</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举的构造都是私有的，所以这里可以省略private，但不是包权限</span></span><br><span class="line">    <span class="comment">//java语言的内置规范.枚举类没有&lt;init&gt;无参构造</span></span><br><span class="line">    EnumSingletonTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private EnumSingletonTest()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public static void otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需要重写toString；不然会打印 ”INSTANCE“</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(<span class="built_in">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingletonTest <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        EnumSingletonTest.otherMethod();</span><br><span class="line">        System.out.println(EnumSingletonTest.getInstance());</span><br><span class="line">        System.out.println(EnumSingletonTest.getInstance());</span><br><span class="line">        System.out.println(<span class="string">&quot;Unsave破坏单例&quot;</span> + getUnsafe().allocateInstance(EnumSingletonTest.class));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反序列化破坏单例</span></span><br><span class="line">        <span class="comment">//失败--》【ObjectInputStream会对枚举类做出识别，不会从文件中生成对象】</span></span><br><span class="line">        serializable(EnumSingletonTest.getInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射破坏单例</span></span><br><span class="line">        <span class="comment">//失败</span></span><br><span class="line">        <span class="comment">// com.itheima.design_pattern.EnumSingletonTest.&lt;init&gt;()没有无参构造报错</span></span><br><span class="line">        <span class="comment">// Cannot reflectively create enum objects枚举类不能通过反射获取对象</span></span><br><span class="line">        reflection(EnumSingletonTest.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            <span class="comment">//因为 Unsafe 的 theUnsafe 字段是private 的，所以这里需要设置成可访问的</span></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//Unsafe 的这个属性 theUnsafe 是静态的所以这里的get参数就是null</span></span><br><span class="line">            <span class="comment">//因为get(Object obj))是获取某个实例的属性，类属性属于类不属于实例，实例只是共享</span></span><br><span class="line">            <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过反序列化获取EnumSingletonTest实例方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializable</span><span class="params">(EnumSingletonTest instance)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        <span class="comment">//字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中</span></span><br><span class="line">        <span class="comment">//ObjectOutputStream会特殊处理枚举类，返回的式枚举类的实例，而不是文件中的字节数组生成的实例</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray()));</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化破坏单例&quot;</span> + ois.readObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过反射获取EnumSingletonTest实例方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reflection</span><span class="params">(Class&lt;EnumSingletonTest&gt; clazz)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;EnumSingletonTest&gt; constructor = clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">//暴力反射</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//没有无参构造报错</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;通过反射获取的实例&quot; + constructor.newInstance());</span></span><br><span class="line">        <span class="comment">//枚举类不能通过反射获取对象</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;通过反射获取的实例&quot; + constructor.newInstance(&quot;OTHER&quot;, 3));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=====================================================</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">EnumSingletonTest</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span><span class="comment">//运行静态方法前先跑静态代码块的内容，即先创建对象（饿汉式）</span></span><br><span class="line">com.itheima.design_pattern.EnumSingletonTest@330bedb4</span><br><span class="line">com.itheima.design_pattern.EnumSingletonTest@330bedb4</span><br><span class="line">Unsave破坏单例com.itheima.design_pattern.EnumSingletonTest@4b67cf4d<span class="comment">//可以破坏</span></span><br><span class="line">反序列化破坏单例com.itheima.design_pattern.EnumSingletonTest@330bedb4<span class="comment">//不可以破坏</span></span><br></pre></td></tr></table></figure>





<h2 id="4-0-懒汉单例"><a href="#4-0-懒汉单例" class="headerlink" title="4.0 懒汉单例"></a>4.0 懒汉单例</h2><h3 id="4-1-双检锁懒汉式"><a href="#4-1-双检锁懒汉式" class="headerlink" title="4.1 双检锁懒汉式"></a>4.1 双检锁懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.design_pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.regexp.internal.RE;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sluggard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量，属于类</span></span><br><span class="line">	<span class="comment">//private static Sluggard INSTANCE;</span></span><br><span class="line">    <span class="comment">//volatile 共享变量，可见性，有序性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Sluggard INSTANCE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sluggard</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Sluggard()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这种方式获取实例，没有线程安全性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sluggard <span class="title function_">getInstance1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当多个线程第一次在还没有创建实例时就都来到这一步时，就会创建多个实例，破坏单例</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Sluggard</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 通过加锁的方式实现线程安全</span></span><br><span class="line"><span class="comment">     * 这里的锁对象时Sluggard.class</span></span><br><span class="line"><span class="comment">     * 当多个线程同时到达这个方法的外部时，只有一个线程可以获得锁进入方法，其他线程挂起</span></span><br><span class="line"><span class="comment">     * 当混进方法的线程执行完逻辑后，其他线程再竞争锁，进入方法，就会发现已有实例，不需要创建</span></span><br><span class="line"><span class="comment">     * 但这个方法有问题:每个线程调用该方法都要等待锁（即使此时，已有实例）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Sluggard <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Sluggard</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 解决上面方法的效率问题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 双检锁懒汉式</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sluggard <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//4.此时实例不为空，就不会存在线程不安全的问题</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//1.当多个线程第一次在还没有创建实例时就都来到这一步时</span></span><br><span class="line">            <span class="comment">//2.多个线程竞争锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Sluggard.class) &#123;</span><br><span class="line">                <span class="comment">//3.第一个竞争到锁的线程创建了实例，在外面等锁的线程，进来之后就不会创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Sluggard</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; public static void otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSingleton1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先调用静态方法，如果是饿汉式，就会调用无参构造获取实例【加载 连接初 始化】</span></span><br><span class="line">        Sluggard.otherMethod();</span><br><span class="line">        System.out.println(Sluggard.getInstance());</span><br><span class="line">        System.out.println(Sluggard.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================================</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span><span class="comment">//懒汉式，调用静态方法没有触发初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Sluggard</span><span class="params">()</span></span><br><span class="line">com.itheima.design_pattern.Sluggard@330bedb4</span><br><span class="line">com.itheima.design_pattern.Sluggard@330bedb4</span><br></pre></td></tr></table></figure>





<h3 id="4-2-为什么要添加valatile修饰符"><a href="#4-2-为什么要添加valatile修饰符" class="headerlink" title="4.2 为什么要添加valatile修饰符"></a>4.2 为什么要添加valatile修饰符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要是为了防止指令重排</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反编译字节码文件查看文件执行指令顺序</span></span><br><span class="line">D:\learn\tencentClass\interview\ChanzPodcast\base\Project\out\production\one\com\itheima\design_pattern&gt;javap -c -v -p Sluggard.class</span><br><span class="line"></span><br><span class="line"> 		<span class="number">17</span>: <span class="keyword">new</span>           #<span class="number">6</span>                  <span class="comment">// class com/itheima/design_pattern/Sluggard</span></span><br><span class="line">        <span class="number">20</span>: dup</span><br><span class="line">        <span class="number">21</span>: invokespecial #<span class="number">7</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">24</span>: putstatic     #<span class="number">5</span>                  <span class="comment">// Field INSTANCE:Lcom/itheima/design_pattern/Sluggard;</span></span><br><span class="line">	<span class="comment">//第17指令，创建对象；在堆内存中开辟出一块空间，根据Sluggard实例的成员变量和方法引用，计算出空间大小；【创建对象就是分配空间】</span></span><br><span class="line">    <span class="comment">//第21指令，调用构造器，为成员变量初始化(没有就赋默认值)</span></span><br><span class="line">    <span class="comment">//第24指令，给静态变量赋值，将创建好的Sluggard对象赋值给静态变量        </span></span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202210232303927.png" alt="image-20221023230321856"></p>
<hr>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202210232304585.png" alt="image-20221023230413726"></p>
<hr>
<ul>
<li>小结</li>
</ul>
<p>为什么懒汉单例没有线程安全问题<br>    静态成员变量在定义的同时赋值，这个赋值操作(给静态成员变量赋值)是会放在该类的静态代码块中；<br>    静态代码块中的线程安全，是由jvm负责的</p>
<h3 id="4-3-内部类实现懒汉单例"><a href="#4-3-内部类实现懒汉单例" class="headerlink" title="4.3 内部类实现懒汉单例"></a>4.3 内部类实现懒汉单例</h3><ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.design_pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: InnerClassSingleton</span></span><br><span class="line"><span class="comment"> * Description:内部类实现懒汉单例</span></span><br><span class="line"><span class="comment"> * date:2022/3/20</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fgcy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassSingleton</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//私有构造</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">InnerClassSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private InnerClassSingleton()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private static void otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="comment">//内部类可以访问外部类的所有成员（本类中）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InnerClassSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClassSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InnerClassSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//静态内部类属于外部类，所以通过外部类类名调用，又因为是在本类，所以可以省略外部类类名</span></span><br><span class="line">		<span class="comment">//return InnerClassSingleton.InnerClass.INSTANCE;</span></span><br><span class="line">        <span class="comment">//碰到类的时候，就会加载静态代码块中的内容（又由于是在静态代码块中，线程是安全的）</span></span><br><span class="line">        <span class="keyword">return</span> InnerClass.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        InnerClassSingleton.otherMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;..........................&quot;</span>);</span><br><span class="line">        System.out.println(InnerClassSingleton.getInstance());</span><br><span class="line">        System.out.println(InnerClassSingleton.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=======================================</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span><span class="comment">//InnerClassSingleton实例的创建在内部类中，这里只是调用了外部类的方法，没有碰到内部类，所以不会调用无参构造</span></span><br><span class="line">..........................</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">InnerClassSingleton</span><span class="params">()</span></span><br><span class="line">com.itheima.design_pattern.InnerClassSingleton@330bedb4</span><br><span class="line">com.itheima.design_pattern.InnerClassSingleton@330bedb4</span><br></pre></td></tr></table></figure>



<h2 id="5-0-jdk有哪些地方体现单例"><a href="#5-0-jdk有哪些地方体现单例" class="headerlink" title="5.0 jdk有哪些地方体现单例"></a>5.0 jdk有哪些地方体现单例</h2><ul>
<li>双检锁懒汉式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   System.java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Console</span> <span class="variable">cons</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Console <span class="title function_">console</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cons == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (System.class) &#123;</span><br><span class="line">                cons = sun.misc.SharedSecrets.getJavaIOAccess().console();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<ul>
<li>饿汉式单例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="comment">//在静态代码块中实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line">	<span class="comment">//提供一个对外访问的入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//私有构造</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//退出虚拟机的方法，非零代表异常退出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">      <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            security.checkExit(status);</span><br><span class="line">        &#125;</span><br><span class="line">        Shutdown.exit(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//告诉虚拟机要做一次垃圾回收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">gc</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>





<ul>
<li>内部类懒汉式单例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> class &lt;E&gt;&#123;</span><br><span class="line">        <span class="comment">//内部类的内部类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmptyNavigableSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">UnmodifiableNavigableSet</span>&lt;E&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">   			<span class="comment">//防止反序列化破坏单例</span></span><br><span class="line">            <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span>&#123; <span class="keyword">return</span> EMPTY_NAVIGABLE_SET; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当有人碰到UnmodifiableNavigableSet时，才会触发初始化</span></span><br><span class="line">        <span class="comment">//EmptyNavigableSet的静态成员变量</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NavigableSet&lt;?&gt; EMPTY_NAVIGABLE_SET =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">EmptyNavigableSet</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//UnmodifiableNavigableSet类返回EmptyNavigableSet单例的方法</span></span><br><span class="line">     <span class="comment">//EmptyNavigableSet的静态成员方法</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; NavigableSet&lt;E&gt; <span class="title function_">emptyNavigableSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (NavigableSet&lt;E&gt;) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">//Collections的静态成员方法</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; SortedSet&lt;E&gt; <span class="title function_">emptySortedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (SortedSet&lt;E&gt;) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<ul>
<li>饿汉单例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">    <span class="comment">//在外部类中创建内部类对象不用带类名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Set</span> <span class="variable">EMPTY_SET</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmptySet</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">emptySet</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Set&lt;T&gt;) EMPTY_SET;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类（使用默认的公开无参构造，但外部类无法访问，私有的内部类）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmptySet</span>&lt;E&gt;&#123;&#125;</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<ul>
<li>枚举饿汉式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;   </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; Comparator&lt;T&gt; <span class="title function_">naturalOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用枚举方法创造的实例</span></span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comparators</span> &#123;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">NaturalOrderComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Comparable&lt;Object&gt;&gt; &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>JDK 中单例的体现</strong></p>
<ul>
<li><code>Runtime </code>   体现了饿汉式单例</li>
<li><code>Console </code>  体现了双检锁懒汉式单例</li>
<li><code>Collections </code> 中的 EmptyNavigableSet 内部类懒汉式单例</li>
<li><code>ReverseComparator.REVERSE_ORDER</code> 内部类懒汉式单例</li>
<li><code>Comparators.NaturalOrderComparator.INSTANCE</code> 枚举饿汉式单例</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/30/%E5%9F%BA%E7%A1%80%E7%AF%87-itcast/" data-id="clfv6vsxd004be4cx19ht2xiy" data-title="基础篇-itcast" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80-itcast/" rel="tag">java基础-itcast</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/03/30/%E5%B9%B6%E5%8F%91%E7%AF%87-itcast/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          并发篇-itcast
        
      </div>
    </a>
  
  
    <a href="/2023/03/30/%E6%A1%86%E6%9E%B6%E7%AF%87-itcast/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">框架篇-itcast</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">博客学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">视频学习笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AIO/" rel="tag">AIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BIO/" rel="tag">BIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO%E6%A8%A1%E5%9E%8B-heima/" rel="tag">IO模型-heima</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM-heima/" rel="tag">JVM-heima</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80-heima/" rel="tag">Java基础-heima</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-atguigu/" rel="tag">Java数据结构与算法-atguigu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis-DongLi/" rel="tag">Mybatis-DongLi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/" rel="tag">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-DongLi/" rel="tag">Spring-DongLi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot-DongLi/" rel="tag">SpringBoot-DongLi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC-DongLi/" rel="tag">SpringMVC-DongLi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringSecurity-sg/" rel="tag">SpringSecurity-sg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-atguigu/" rel="tag">Vue-atguigu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo-heima/" rel="tag">dubbo-heima</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git-atguigu/" rel="tag">git-atguigu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80-itcast/" rel="tag">java基础-itcast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%B9%B6%E5%8F%91-itcast/" rel="tag">java并发-itcast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A1%86%E6%9E%B6-itcast/" rel="tag">java框架-itcast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA-itcast/" rel="tag">java虚拟机-itcast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-DongLi/" rel="tag">动态代理-DongLi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" rel="tag">尚硅谷</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-MySQL-%E5%88%9D%E7%BA%A7/" rel="tag">尚硅谷-宋红康-MySQL(初级)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-MySQL-%E9%AB%98%E7%BA%A7/" rel="tag">尚硅谷-宋红康-MySQL(高级)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-msb/" rel="tag">操作系统基础-msb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" rel="tag">网络基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A9%AC%E5%A3%AB%E5%85%B5/" rel="tag">马士兵</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AIO/" style="font-size: 10px;">AIO</a> <a href="/tags/BIO/" style="font-size: 10px;">BIO</a> <a href="/tags/IO%E6%A8%A1%E5%9E%8B-heima/" style="font-size: 10px;">IO模型-heima</a> <a href="/tags/JVM-heima/" style="font-size: 10px;">JVM-heima</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80-heima/" style="font-size: 20px;">Java基础-heima</a> <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-atguigu/" style="font-size: 10px;">Java数据结构与算法-atguigu</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis-DongLi/" style="font-size: 10px;">Mybatis-DongLi</a> <a href="/tags/NIO/" style="font-size: 10px;">NIO</a> <a href="/tags/Spring-DongLi/" style="font-size: 10px;">Spring-DongLi</a> <a href="/tags/SpringBoot-DongLi/" style="font-size: 10px;">SpringBoot-DongLi</a> <a href="/tags/SpringMVC-DongLi/" style="font-size: 10px;">SpringMVC-DongLi</a> <a href="/tags/SpringSecurity-sg/" style="font-size: 10px;">SpringSecurity-sg</a> <a href="/tags/Vue-atguigu/" style="font-size: 10px;">Vue-atguigu</a> <a href="/tags/dubbo-heima/" style="font-size: 10px;">dubbo-heima</a> <a href="/tags/git-atguigu/" style="font-size: 10px;">git-atguigu</a> <a href="/tags/java%E5%9F%BA%E7%A1%80-itcast/" style="font-size: 10px;">java基础-itcast</a> <a href="/tags/java%E5%B9%B6%E5%8F%91-itcast/" style="font-size: 10px;">java并发-itcast</a> <a href="/tags/java%E6%A1%86%E6%9E%B6-itcast/" style="font-size: 10px;">java框架-itcast</a> <a href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA-itcast/" style="font-size: 10px;">java虚拟机-itcast</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-DongLi/" style="font-size: 10px;">动态代理-DongLi</a> <a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" style="font-size: 10px;">尚硅谷</a> <a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-MySQL-%E5%88%9D%E7%BA%A7/" style="font-size: 13.33px;">尚硅谷-宋红康-MySQL(初级)</a> <a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%AE%8B%E7%BA%A2%E5%BA%B7-MySQL-%E9%AB%98%E7%BA%A7/" style="font-size: 16.67px;">尚硅谷-宋红康-MySQL(高级)</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-msb/" style="font-size: 10px;">操作系统基础-msb</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">网络基础</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A9%AC%E5%A3%AB%E5%85%B5/" style="font-size: 10px;">马士兵</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/30/%E7%AC%AC03%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5-atguigu-shk/">第03章-基本的SELECT语句-atguigu-shk</a>
          </li>
        
          <li>
            <a href="/2023/03/30/char%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-heima-xl/">char数据类型-heima-xl</a>
          </li>
        
          <li>
            <a href="/2023/03/30/Collection%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8EList%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%B7%B1%E5%85%A5-heima-xl/">Collection与数据结构与List与泛型深入-heima-xl</a>
          </li>
        
          <li>
            <a href="/2023/03/30/JAVA-IO-%E4%B8%8B-heima-xl/">JAVA-IO-下-heima-xl</a>
          </li>
        
          <li>
            <a href="/2023/03/30/Set%E4%B8%8ECollections%E4%B8%8EMap%E4%B8%8E%E9%9B%86%E5%90%88%E5%B5%8C%E5%A5%97-heima-xl/">Set与Collections与Map与集合嵌套-heima-xl</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>